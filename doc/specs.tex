\tabletail{\hline}
\begin{supertabular}{|l|l|} \hline
\multicolumn{2}{|l|}{\bf \bvec } \\ \hline
{\tt bvec } & a boolean vector  \\\hline
{\tt bvec\_add } & builds a boolean vector for addition  \\\hline
{\tt bvec\_addref } & increase reference count of a boolean vector  \\\hline
{\tt bvec\_coerce } & adjust the size of a boolean vector  \\\hline
{\tt bvec\_con } & build a boolean vector representing an integer value  \\\hline
{\tt bvec\_copy } & create a copy of a bvec  \\\hline
{\tt bvec\_delref } & decrease the reference count of a boolean vector  \\\hline
{\tt bvec\_div } & builds a boolean vector for division  \\\hline
{\tt bvec\_divfixed } & builds a boolean vector for division by a constant  \\\hline
{\tt bvec\_equ } & calculates the truth value of $x = y$  \\\hline
{\tt bvec\_false } & build a vector of constant false BDDs  \\\hline
{\tt bvec\_free } & frees all memory used by a boolean vector  \\\hline
{\tt bvec\_gte } & calculates the truth value of $x \geq y$  \\\hline
{\tt bvec\_gth } & calculates the truth value of $x > y$  \\\hline
{\tt bvec\_isconst } & test a vector for constant true/false BDDs  \\\hline
{\tt bvec\_ite } & calculates the if-then-else operator for a boolean vector  \\\hline
{\tt bvec\_lte } & calculates the truth value of $x \leq y$  \\\hline
{\tt bvec\_lth } & calculates the truth value of $x < y$  \\\hline
{\tt bvec\_map1 } & map a function onto a boolean vector  \\\hline
{\tt bvec\_map2 } & map a function onto a boolean vector  \\\hline
{\tt bvec\_map3 } & map a function onto a boolean vector  \\\hline
{\tt bvec\_mul } & builds a boolean vector for multiplication  \\\hline
{\tt bvec\_mulfixed } & builds a boolean vector for multiplication with a constant  \\\hline
{\tt bvec\_neq } & calculates the truth value of $x \neq y$  \\\hline
{\tt bvec\_shl } & shift left operation (symbolic)  \\\hline
{\tt bvec\_shlfixed } & shift left operation (fixed number of bits)  \\\hline
{\tt bvec\_shr } & shift right operation (symbolic)  \\\hline
{\tt bvec\_shrfixed } & shift right operation  \\\hline
{\tt bvec\_sub } & builds a boolean vector for subtraction  \\\hline
{\tt bvec\_true } & build a vector of constant true BDDs  \\\hline
{\tt bvec\_val } & calculate the integer value represented by a boolean vector  \\\hline
{\tt bvec\_var } & build a boolean vector with BDD variables  \\\hline
{\tt bvec\_varfdd } & build a boolean vector from a FDD variable block  \\\hline
{\tt bvec\_varvec } & build a boolean vector with the variables passed in an array  \\\hline
\multicolumn{2}{|l|}{\bf \fdd } \\ \hline
{\tt fdd\_clearall } & clear all allocated FDD blocks  \\\hline
{\tt fdd\_domain } & bDD encoding of the domain of a FDD variable  \\\hline
{\tt fdd\_domainnum } & number of defined finite domain blocks  \\\hline
{\tt fdd\_domainsize } & real size of a finite domain block  \\\hline
{\tt fdd\_equals } & returns a BDD setting two FD. blocks equal  \\\hline
{\tt fdd\_extdomain } & adds another set of finite domain blocks  \\\hline
{\tt fdd\_file\_hook } & specifies a printing callback handler  \\\hline
{\tt fdd\_intaddvarblock } & adds a new variable block for reordering  \\\hline
{\tt fdd\_ithset } & the variable set for the i'th finite domain block  \\\hline
{\tt fdd\_ithvar } & the BDD for the i'th FDD set to a specific value  \\\hline
{\tt fdd\_makeset } & creates a variable set for N finite domain blocks  \\\hline
{\tt fdd\_overlapdomain } & combine two FDD blocks into one  \\\hline
{\tt fdd\_printset } & prints a BDD for a finite domain block  \\
{\tt fdd\_fprintset } & \\\hline
{\tt fdd\_scanallvar } & finds one satisfying value of all FDD variables  \\\hline
{\tt fdd\_scanset } & scans a variable set  \\\hline
{\tt fdd\_scanvar } & finds one satisfying value of a FDD variable  \\\hline
{\tt fdd\_setpair } & defines a pair for two finite domain blocks  \\\hline
{\tt fdd\_setpairs } & defines N pairs for finite domain blocks  \\\hline
{\tt fdd\_strm\_hook } & specifies a printing callback handler  \\\hline
{\tt fdd\_varnum } & binary size of a finite domain block  \\\hline
{\tt fdd\_vars } & all BDD variables associated with a finite domain block  \\\hline
\multicolumn{2}{|l|}{\bf \fileio } \\ \hline
{\tt bdd\_load } & loads a BDD from a file  \\
{\tt bdd\_fnload } & \\\hline
{\tt bdd\_printall } & prints all used entries in the node table  \\
{\tt bdd\_fprintall } & \\\hline
{\tt bdd\_printdot } & prints a description of a BDD in DOT format  \\
{\tt bdd\_fprintdot } & \\\hline
{\tt bdd\_printset } & prints the set of truth assignments specified by a BDD  \\
{\tt bdd\_fprintset } & \\\hline
{\tt bdd\_printtable } & prints the node table entries used by a BDD  \\
{\tt bdd\_fprinttable } & \\\hline
{\tt bdd\_save } & saves a BDD to a file  \\
{\tt bdd\_fnsave } & \\\hline
{\tt operator{\tt<<} } & c++ output operator for BDDs  \\\hline
\multicolumn{2}{|l|}{\bf \info } \\ \hline
{\tt bdd\_anodecount } & counts the number of shared nodes in an array of BDDs  \\\hline
{\tt bdd\_high } & gets the true branch of a bdd   \\\hline
{\tt bdd\_low } & gets the false branch of a bdd   \\\hline
{\tt bdd\_nodecount } & counts the number of nodes used for a BDD  \\\hline
{\tt bdd\_pathcount } & count the number of paths leading to the true terminal  \\\hline
{\tt bdd\_satcount } & calculates the number of satisfying variable assignments  \\
{\tt bdd\_setcountset } & \\\hline
{\tt bdd\_satcountln } & calculates the log. number of satisfying variable assignments  \\
{\tt bdd\_setcountlnset } & \\\hline
{\tt bdd\_support } & returns the variable support of a BDD  \\\hline
{\tt bdd\_var } & gets the variable labeling the bdd  \\\hline
{\tt bdd\_varprofile } & returns a variable profile  \\\hline
\multicolumn{2}{|l|}{\bf \kernel } \\ \hline
{\tt bddCacheStat } & status information about cache usage  \\\hline
{\tt bddGbcStat } & status information about garbage collections  \\\hline
{\tt bddStat } & status information about the bdd package  \\\hline
{\tt bdd\_addref } & increases the reference count on a node  \\\hline
{\tt bdd\_cachestats } & fetch cache access usage  \\\hline
{\tt bdd\_clear\_error } & clears an error condition in the kernel  \\\hline
{\tt bdd\_delref } & decreases the reference count on a node  \\\hline
{\tt bdd\_done} & resets the bdd package  \\\hline
{\tt bdd\_error\_hook } & set a handler for error conditions  \\\hline
{\tt bdd\_errstring } & converts an error code to a string \\\hline
{\tt bdd\_extvarnum } & add extra BDD variables  \\\hline
{\tt bdd\_false } & returns the constant false bdd  \\\hline
{\tt bdd\_file\_hook } & specifies a printing callback handler  \\\hline
{\tt bdd\_freepair } & frees a table of pairs  \\\hline
{\tt bdd\_gbc\_hook } & set a handler for garbage collections  \\\hline
{\tt bdd\_getallocnum } & get the number of allocated nodes  \\\hline
{\tt bdd\_getnodenum } & get the number of active nodes in use  \\\hline
{\tt bdd\_init } & initializes the BDD package  \\\hline
{\tt bdd\_isrunning } & test whether the package is started or not  \\\hline
{\tt bdd\_ithvar } & returns a bdd representing the I'th variable  \\\hline
{\tt bdd\_makeset } & builds a BDD variable set from an integer array  \\\hline
{\tt bdd\_newpair } & creates an empty variable pair table  \\\hline
{\tt bdd\_nithvar } & returns a bdd representing the negation of the I'th variable  \\\hline
{\tt bdd\_printstat } & print cache statistics  \\
{\tt bdd\_fprintstat } & \\\hline
{\tt bdd\_resetpair } & clear all variable pairs  \\\hline
{\tt bdd\_resize\_hook  } & set a handler for nodetable resizes  \\\hline
{\tt bdd\_scanset } & returns an integer representation of a variable set  \\\hline
{\tt bdd\_setcacheratio } & sets the cache ratio for the operator caches  \\\hline
{\tt bdd\_setmaxincrease } & set max. number of nodes used to increase node table  \\\hline
{\tt bdd\_setmaxnodenum } & set the maximum available number of bdd nodes  \\\hline
{\tt bdd\_setminfreenodes } & set min. no. of nodes to be reclaimed after GBC.  \\\hline
{\tt bdd\_setpair } & set one variable pair  \\
{\tt bdd\_setbddpair } & \\\hline
{\tt bdd\_setpairs } & defines a whole set of pairs  \\
{\tt bdd\_setbddpairs } & \\\hline
{\tt bdd\_setvarnum } & set the number of used bdd variables  \\\hline
{\tt bdd\_stats } & returns some status information about the bdd package  \\\hline
{\tt bdd\_strm\_hook } & specifies a printing callback handler  \\\hline
{\tt bdd\_true } & returns the constant true bdd  \\\hline
{\tt bdd\_varnum } & returns the number of defined variables  \\\hline
{\tt bdd\_versionnum } & returns the version number of the bdd package  \\\hline
{\tt bdd\_versionstr } & returns a text string with version information  \\\hline
{\tt bddfalse} & the constant false bdd  \\\hline
{\tt bddtrue } & the constant true bdd  \\\hline
\multicolumn{2}{|l|}{\bf \operator } \\ \hline
{\tt bdd\_allsat } & finds all satisfying variable assignments  \\\hline
{\tt bdd\_and } & the logical 'and' of two BDDs  \\\hline
{\tt bdd\_appall } & apply operation and universal quantification  \\\hline
{\tt bdd\_appex } & apply operation and existential quantification  \\\hline
{\tt bdd\_apply } & basic bdd operations  \\\hline
{\tt bdd\_appuni } & apply operation and unique quantification  \\\hline
{\tt bdd\_biimp } & the logical 'bi-implication' between two BDDs  \\\hline
{\tt bdd\_buildcube } & build a cube from an array of variables  \\
{\tt bdd\_ibuildcube } & \\\hline
{\tt bdd\_compose } & functional composition  \\\hline
{\tt bdd\_constrain } & generalized cofactor  \\\hline
{\tt bdd\_exist } & existential quantification of variables  \\\hline
{\tt bdd\_forall } & universal quantification of variables  \\\hline
{\tt bdd\_fullsatone } & finds one satisfying variable assignment  \\\hline
{\tt bdd\_imp } & the logical 'implication' between two BDDs  \\\hline
{\tt bdd\_ite } & if-then-else operator  \\\hline
{\tt bdd\_not } & negates a bdd  \\\hline
{\tt bdd\_or } & the logical 'or' of two BDDs  \\\hline
{\tt bdd\_relprod } & relational product  \\\hline
{\tt bdd\_replace } & replaces variables with other variables  \\\hline
{\tt bdd\_restrict } & restric a set of variables to constant values  \\\hline
{\tt bdd\_satone } & finds one satisfying variable assignment  \\\hline
{\tt bdd\_satoneset } & finds one satisfying variable assignment  \\\hline
{\tt bdd\_simplify } & coudert and Madre's restrict function  \\\hline
{\tt bdd\_unique } & unique quantification of variables  \\\hline
{\tt bdd\_veccompose } & simultaneous functional composition  \\\hline
{\tt bdd\_xor } & the logical 'xor' of two BDDs  \\\hline
\multicolumn{2}{|l|}{\bf \reorder } \\ \hline
{\tt bdd\_addvarblock } & adds a new variable block for reordering  \\
{\tt bdd\_intaddvarblock } & \\\hline
{\tt bdd\_autoreorder } & enables automatic reordering  \\
{\tt bdd\_autoreorder\_times } & \\\hline
{\tt bdd\_blockfile\_hook } & specifies a printing callback handler  \\\hline
{\tt bdd\_clrvarblocks } & clears all variable blocks  \\\hline
{\tt bdd\_disable\_reorder } & disable automatic reordering  \\\hline
{\tt bdd\_enable\_reorder } & enables automatic reordering  \\\hline
{\tt bdd\_getreorder\_method } & fetch the current reorder method  \\\hline
{\tt bdd\_getreorder\_times } & fetch the current number of allowed reorderings  \\\hline
{\tt bdd\_level2var } & fetch the variable number of a specific level  \\\hline
{\tt bdd\_printorder } & prints the current order  \\\hline
{\tt bdd\_reorder } & start dynamic reordering  \\\hline
{\tt bdd\_reorder\_gain } & calculate the gain in size after a reordering  \\\hline
{\tt bdd\_reorder\_hook } & sets a handler for automatic reorderings  \\\hline
{\tt bdd\_reorder\_probe } & define a handler for minimization of BDDs  \\\hline
{\tt bdd\_reorder\_verbose } & enables verbose information about reorderings  \\\hline
{\tt bdd\_setvarorder } & set a specific variable order  \\\hline
{\tt bdd\_swapvar } & swap two BDD variables  \\\hline
{\tt bdd\_var2level } & fetch the level of a specific BDD variable  \\\hline
{\tt bdd\_varblockall } & add a variable block for all variables  \\ 
\end{supertabular}
\newpage \noindent 
\begin{minipage}{\textwidth}

% === bddCacheStat  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bddCacheStat }
\addcontentsline{toc}{section}{bddCacheStat }
\index{bddCacheStat }
\--- Status information about cache usage  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
typedef struct s_bddCacheStat
{
   long unsigned int uniqueAccess;
   long unsigned int uniqueChain;
   long unsigned int uniqueHit;
   long unsigned int uniqueMiss;
   long unsigned int opHit;
   long unsigned int opMiss;
   long unsigned int swapCount;
} bddCacheStat; 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
The fields are \\[\baselineskip] \begin{tabular}{ll}
  {\bf Name}         & {\bf Number of } \\
  uniqueAccess & accesses to the unique node table \\
  uniqueChain  & iterations through the cache chains in the unique node table\\
  uniqueHit    & entries actually found in the the unique node table \\
  uniqueMiss   & entries not found in the the unique node table \\
  opHit        & entries found in the operator caches \\
  opMiss       & entries not found in the operator caches \\
  swapCount    & number of variable swaps in reordering \\
\end{tabular} 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_cachestats 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bddGbcStat  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bddGbcStat }
\addcontentsline{toc}{section}{bddGbcStat }
\index{bddGbcStat }
\--- Status information about garbage collections  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
typedef struct s_bddGbcStat
{
   int nodes;
   int freenodes;
   long time;
   long sumtime;
   int num;
} bddGbcStat;  
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
The fields are \\[\baselineskip] \begin{tabular}{ll}
  {\tt nodes}     & Total number of allocated nodes in the nodetable \\
  {\tt freenodes} & Number of free nodes in the nodetable \\
  {\tt time}      & Time used for garbage collection this time \\
  {\tt sumtime}   & Total time used for garbage collection \\
  {\tt num}       & number of garbage collections done until now
  \end{tabular} 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_gbc\_hook 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bddStat  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bddStat }
\addcontentsline{toc}{section}{bddStat }
\index{bddStat }
\--- Status information about the bdd package  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
typedef struct s_bddStat
{
   long int produced;
   int nodenum;
   int maxnodenum;
   int freenodes;
   int minfreenodes;
   int varnum;
   int cachesize;
   int gbcnum;
} bddStat;  
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
The fields are \\[\baselineskip] \begin{tabular}{lp{10cm}}
  {\tt produced}     & total number of new nodes ever produced \\
  {\tt nodenum}      & currently allocated number of bdd nodes \\
  {\tt maxnodenum}   & user defined maximum number of bdd nodes \\
  {\tt freenodes}    & number of currently free nodes \\
  {\tt minfreenodes} & minimum number of nodes that should be left after a
                       garbage collection. \\
  {\tt varnum}       & number of defined bdd variables \\
  {\tt cachesize}    & number of entries in the internal caches \\
  {\tt gbcnum}       & number of garbage collections done until now
  \end{tabular} 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_stats 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_addref  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_addref }
\addcontentsline{toc}{section}{bdd\_addref }
\index{bdd\_addref }
\--- increases the reference count on a node  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_addref(BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Reference counting is done on externaly referenced nodes only
           and the count for a specific node {\tt r} can and must be
	   increased using this function to avoid loosing the node in the next
	   garbage collection. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The BDD node {\tt r}. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_delref 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_addvarblock  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_addvarblock }
\addcontentsline{toc}{section}{bdd\_addvarblock }
\index{bdd\_addvarblock }
\--- adds a new variable block for reordering  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_addvarblock(BDD var, int fixed)
int bdd_intaddvarblock(int first, int last, int fixed) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Creates a new variable block with the variables in the variable
           set {\tt var}. The variables in {\tt var} must be contiguous.
	   In the second form the argument {\tt first} is the first variable
	   included in the block and {\tt last} is the last variable included
	   in the block. This order does not depend on current variable
	   order.

	   The variable blocks are ordered as a tree, with the largest
	   ranges at top and the smallest at the bottom. Example: Assume
	   the block 0-9 is added as the first block and then the block 0-6.
	   This yields the 0-9 block at the top, with the 0-6 block as a
	   child. If now the block 2-4 was added, it would become a child
	   of the 0-6 block. A block of 0-8 would be a child of the 0-9
	   block and have the 0-6 block as a child. Partially overlapping
	   blocks are not allowed.

	   The {\tt fixed} parameter sets the block to be fixed (no
	   reordering of its child blocks is allowed) or free, using
	   the constants {\tt BDD\_REORDER\_FIXED} and {\tt
	   BDD\_REORDER\_FREE}.  Reordering is always done on the top
	   most blocks first and then recursively downwards.

	   The return value is an integer that can be used to identify
	   the block later on - with for example {\tt bdd\_blockfile\_hook}.
	   The values returned will be in the sequence $0,1,2,3,\ldots$.
	   

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
A non-negative identifier on success, otherwise a negative error code. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_varblockall, fdd\_intaddvarblock, bdd\_clrvarblocks 
\addcontentsline{toc}{section}{bdd\_intaddvarblock }
\index{bdd\_intaddvarblock }
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_allsat  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_allsat }
\addcontentsline{toc}{section}{bdd\_allsat }
\index{bdd\_allsat }
\--- finds all satisfying variable assignments  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_satone(BDD r, bddallsathandler handler) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Iterates through all legal variable assignments (those
           that make the BDD come true) for the  bdd {\tt r} and
	   calls the callback handler {\tt handler} for each of them.
	   The array passed to {\tt handler} contains one entry for
	   each of the globaly defined variables. Each entry is either
	   0 if the variable is false, 1 if it is true, and -1 if it
	   is a don't care.

	   The following is an example of a callback handler that
	   prints 'X' for don't cares, '0' for zero, and '1' for one:
	   \begin{verbatim}
void allsatPrintHandler(char* varset, int size)
{
  for (int v=0; v<size ; ++v)
  {
    cout << (varset[v] < 0 ? 'X' : (char)('0' + varset[v]));
  }
  cout << endl;
}
\end{verbatim}

           \noindent
	   The handler can be used like this:
	   {\tt bdd\_allsat(r, allsatPrintHandler); } 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_satone bdd\_satoneset, bdd\_fullsatone, bdd\_satcount, bdd\_satcountln 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_and  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_and }
\addcontentsline{toc}{section}{bdd\_and }
\index{bdd\_and }
\--- The logical 'and' of two BDDs  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_and(BDD l, BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This a wrapper that calls {\tt bdd\_apply(l,r,bddop\_and)}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The logical 'and' of {\tt l} and {\tt r}. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_apply, bdd\_or, bdd\_xor 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_anodecount  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_anodecount }
\addcontentsline{toc}{section}{bdd\_anodecount }
\index{bdd\_anodecount }
\--- counts the number of shared nodes in an array of BDDs  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_anodecount(BDD *r, int num) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Traverses all of the BDDs in {\tt r} and counts all distinct nodes
           that are used in the BDDs--if a node is used in more than one
	   BDD then it only counts once. The {\tt num} parameter holds the
	   size of the array. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The number of nodes 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_nodecount 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_appall  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_appall }
\addcontentsline{toc}{section}{bdd\_appall }
\index{bdd\_appall }
\--- apply operation and universal quantification  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_appall(BDD left, BDD right, int opr, BDD var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Applies the binary operator {\tt opr} to the arguments
           {\tt left} and {\tt right} and then performs an universal
	   quantification of the variables from the variable set
	   {\tt var}. This is done in a bottom up manner such that both the
	   apply and quantification is done on the lower nodes before
	   stepping up to the higher nodes. This makes the {\tt bdd\_appall}
	   function much more efficient than an apply operation followed
	   by a quantification. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The result of the operation. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_appex, bdd\_appuni, bdd\_apply, bdd\_exist, bdd\_forall, bdd\_unique, bdd\_makeset 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_appex  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_appex }
\addcontentsline{toc}{section}{bdd\_appex }
\index{bdd\_appex }
\--- apply operation and existential quantification  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_appex(BDD left, BDD right, int opr, BDD var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Applies the binary operator {\tt opr} to the arguments
           {\tt left} and {\tt right} and then performs an existential
	   quantification of the variables from the variable set
	   {\tt var}. This is done in a bottom up manner such that both the
	   apply and quantification is done on the lower nodes before
	   stepping up to the higher nodes. This makes the {\tt bdd\_appex}
	   function much more efficient than an apply operation followed
	   by a quantification. If the operator is a conjunction then this
	   is similar to the relational product of the two BDDs.
	   \index{relational product} 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The result of the operation. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_appall, bdd\_appuni, bdd\_apply, bdd\_exist, bdd\_forall, bdd\_unique, bdd\_makeset 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_apply  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_apply }
\addcontentsline{toc}{section}{bdd\_apply }
\index{bdd\_apply }
\--- basic bdd operations  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_apply(BDD left, BDD right, int opr) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
The {\tt bdd\_apply} function performs all of the basic
           bdd operations with two operands, such as AND, OR etc.
	   The {\tt left} argument is the left bdd operand and {\tt right}
	   is the right operand. The {\tt opr} argument is the requested
	   operation and must be one of the following\\
	   
   \begin{tabular}{lllc}
     {\bf Identifier}    & {\bf Description} & {\bf Truth table}
        & {\bf C++ opr.} \\
     {\tt bddop\_and}    & logical and    ($A \wedge B$)         & [0,0,0,1]
        & \verb%&% \\
     {\tt bddop\_xor}    & logical xor    ($A \oplus B$)         & [0,1,1,0]
        & \verb%^% \\
     {\tt bddop\_or}     & logical or     ($A \vee B$)           & [0,1,1,1]
        & \verb%|% \\
     {\tt bddop\_nand}   & logical not-and                       & [1,1,1,0] \\
     {\tt bddop\_nor}    & logical not-or                        & [1,0,0,0] \\
     {\tt bddop\_imp}    & implication    ($A \Rightarrow B$)    & [1,1,0,1]
        & \verb%>>% \\
     {\tt bddop\_biimp}  & bi-implication ($A \Leftrightarrow B$)& [1,0,0,1] \\
     {\tt bddop\_diff}   & set difference ($A \setminus B$)      & [0,0,1,0]
        & \verb%-% \\
     {\tt bddop\_less}   & less than      ($A < B$)              & [0,1,0,0]
        & \verb%<% \\
     {\tt bddop\_invimp} & reverse implication ($A \Leftarrow B$)& [1,0,1,1]
        & \verb%<<% \\
   \end{tabular}
   

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The result of the operation. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_ite 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_appuni  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_appuni }
\addcontentsline{toc}{section}{bdd\_appuni }
\index{bdd\_appuni }
\--- apply operation and unique quantification  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_appuni(BDD left, BDD right, int opr, BDD var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Applies the binary operator {\tt opr} to the arguments
           {\tt left} and {\tt right} and then performs a unique
	   quantification of the variables from the variable set
	   {\tt var}. This is done in a bottom up manner such that both the
	   apply and quantification is done on the lower nodes before
	   stepping up to the higher nodes. This makes the {\tt bdd\_appuni}
	   function much more efficient than an apply operation followed
	   by a quantification. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The result of the operation. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_appex, bdd\_appall, bdd\_apply, bdd\_exist, bdd\_unique, bdd\_forall, bdd\_makeset 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_autoreorder  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_autoreorder }
\addcontentsline{toc}{section}{bdd\_autoreorder }
\index{bdd\_autoreorder }
\--- enables automatic reordering  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_autoreorder(int method)
int bdd_autoreorder_times(int method, int num) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Enables automatic reordering using {\tt method} as the reordering
           method. If {\tt method} is {\tt BDD\_REORDER\_NONE} then
           automatic reordering is disabled. Automatic
	   reordering is done every time the number of active nodes in the
	   node table has been doubled and works by interrupting the current
	   BDD operation, doing the reordering and the retrying the operation.

	   In the second form the argument {\tt num} specifies the allowed
	   number of reorderings. So if for example a "one shot" reordering
	   is needed, then the {\tt num} argument would be set to one.

	   Values for {\tt method} can be found under {\tt bdd\_reorder}.
	   

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
Returns the old value of {\tt method} 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_reorder 
\addcontentsline{toc}{section}{bdd\_autoreorder\_times }
\index{bdd\_autoreorder\_times }
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_biimp  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_biimp }
\addcontentsline{toc}{section}{bdd\_biimp }
\index{bdd\_biimp }
\--- The logical 'bi-implication' between two BDDs  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_biimp(BDD l, BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This a wrapper that calls {\tt bdd\_apply(l,r,bddop\_biimp)}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The logical 'bi-implication' of {\tt l} and {\tt r} ($l \Leftrightarrow r$). 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_apply, bdd\_imp 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_blockfile\_hook  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_blockfile\_hook }
\addcontentsline{toc}{section}{bdd\_blockfile\_hook }
\index{bdd\_blockfile\_hook }
\--- Specifies a printing callback handler  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bddfilehandler bdd_blockfile_hook(bddfilehandler handler) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
A printing callback handler is used to convert the variable
           block identifiers into something readable by the end user. Use
	   {\tt bdd\_blockfile\_hook} to pass a handler to BuDDy. A typical
	   handler could look like this:
\begin{verbatim}
void printhandler(FILE *o, int block)
{
   extern char **blocknames;
   fprintf(o, "%s", blocknames[block]);
}
\end{verbatim}
           \noindent
           The handler is then called from {\tt bdd\_printorder} and
	   {\tt bdd\_reorder} (depending on the verbose level) with
           the block numbers returned by {\tt bdd\_addvarblock} as arguments.
	   No default handler is supplied. The argument {\tt handler} may be
	   NULL if no handler is needed. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The old handler 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_printorder 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_buildcube  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_buildcube }
\addcontentsline{toc}{section}{bdd\_buildcube }
\index{bdd\_buildcube }
\--- build a cube from an array of variables  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_buildcube(int value, int width, BDD *var)
BDD bdd_ibuildcube(int value, int width, int *var)
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function builds a cube from the variables in {\tt
           var}. It does so by interpreting the {\tt width} low order
	   bits of {\tt value} as a bit mask--a set bit indicates that the
	   variable should be added in it's positive form, and a cleared
	   bit the opposite. The most significant bits are encoded with
	   the first variables in {\tt var}. Consider as an example
	   the call {\tt bdd\_buildcube(0xB, 4, var)}. This corresponds
	   to the expression: $var[0] \conj \neg var[1] \conj var[2]
	   \conj var[3]$. The first version of the function takes an array
	   of BDDs, whereas the second takes an array of variable numbers
	   as used in {\tt bdd\_ithvar}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The resulting cube 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_ithvar, fdd\_ithvar 
\addcontentsline{toc}{section}{bdd\_ibuildcube }
\index{bdd\_ibuildcube }
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_cachestats  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_cachestats }
\addcontentsline{toc}{section}{bdd\_cachestats }
\index{bdd\_cachestats }
\--- Fetch cache access usage  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_cachestats(bddCacheStat *s) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Fetches cache usage information and stores it in {\tt s}. The
           fields of {\tt s} can be found in the documentaion for
	   {\tt bddCacheStat}. This function may or may not be compiled
	   into the BuDDy package - depending on the setup at compile
	   time of BuDDy. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bddCacheStat, bdd\_printstat 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_clear\_error  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_clear\_error }
\addcontentsline{toc}{section}{bdd\_clear\_error }
\index{bdd\_clear\_error }
\--- clears an error condition in the kernel  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_clear_error(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
The BuDDy kernel may at some point run out of new ROBDD nodes if
           a maximum limit is set with {\tt bdd\_setmaxnodenum}. In this case
	   the current error handler is called and an internal error flag
	   is set. Further calls to BuDDy will always return {\tt bddfalse}.
	   From here BuDDy must either be restarted or {\tt bdd\_clear\_error}
	   may be called after action is taken to let BuDDy continue. This may
	   not be especially usefull since the default error handler exits
	   the program - other needs may of course exist.

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_error\_hook, bdd\_setmaxnodenum 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_clrvarblocks  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_clrvarblocks }
\addcontentsline{toc}{section}{bdd\_clrvarblocks }
\index{bdd\_clrvarblocks }
\--- clears all variable blocks  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_clrvarblocks(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Clears all the variable blocks that has been defined by calls
           to bdd\_addvarblock. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_addvarblock 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_compose  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_compose }
\addcontentsline{toc}{section}{bdd\_compose }
\index{bdd\_compose }
\--- functional composition  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_compose(BDD f, BDD g, int var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Substitutes the variable {\tt var} with the BDD {\tt g} in
           the BDD {\tt f}: result $= f[g/var]$. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The composed BDD 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_veccompose, bdd\_replace, bdd\_restrict 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_constrain  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_constrain }
\addcontentsline{toc}{section}{bdd\_constrain }
\index{bdd\_constrain }
\--- generalized cofactor  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_constrain(BDD f, BDD c) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Computes the generalized cofactor of {\tt f} with respect to
           {\tt c}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The constrained BDD 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_restrict, bdd\_simplify 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_delref  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_delref }
\addcontentsline{toc}{section}{bdd\_delref }
\index{bdd\_delref }
\--- decreases the reference count on a node  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_delref(BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Reference counting is done on externaly referenced nodes only
           and the count for a specific node {\tt r} can and must be
	   decreased using this function to make it possible to reclaim the
	   node in the next garbage collection. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The BDD node {\tt r}. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_addref 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_disable\_reorder  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_disable\_reorder }
\addcontentsline{toc}{section}{bdd\_disable\_reorder }
\index{bdd\_disable\_reorder }
\--- Disable automatic reordering  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_disable_reorder(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Disables automatic reordering until {\tt bdd\_enable\_reorder}
           is called. Reordering is enabled by default as soon as any variable
	   blocks have been defined. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_enable\_reorder 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_done ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_done}
\addcontentsline{toc}{section}{bdd\_done}
\index{bdd\_done}
\--- resets the bdd package  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_done(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function frees all memory used by the bdd package and resets
         the package to it's initial state.

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_init 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_enable\_reorder  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_enable\_reorder }
\addcontentsline{toc}{section}{bdd\_enable\_reorder }
\index{bdd\_enable\_reorder }
\--- Enables automatic reordering  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_enable_reorder(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Re-enables reordering after a call to {\tt bdd\_disable\_reorder}. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_disable\_reorder 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_error\_hook  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_error\_hook }
\addcontentsline{toc}{section}{bdd\_error\_hook }
\index{bdd\_error\_hook }
\--- set a handler for error conditions  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bddinthandler bdd_error_hook(bddinthandler handler) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Whenever an error occurs in the bdd package a test is done to
        see if an error handler is supplied by the user and if such exists
	then it will be called
	with an error code in the variable {\tt errcode}. The handler may
	then print any usefull information and return or exit afterwards.

	This function sets the handler to be {\tt handler}. If a {\tt NULL}
	argument is supplied then no calls are made when an error occurs.
	Possible error codes are found in {\tt bdd.h}. The default handler
	is {\tt bdd\_default\_errhandler} which will use {\tt exit()} to
	terminate the program.

	Any handler should be defined like this:
	\begin{verbatim}
void my_error_handler(int errcode)
{
   ...
}
\end{verbatim} 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The previous handler 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_errstring 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_errstring  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_errstring }
\addcontentsline{toc}{section}{bdd\_errstring }
\index{bdd\_errstring }
\--- converts an error code to a string \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
const char *bdd_errstring(int errorcode) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Converts a negative error code {\tt errorcode} to a descriptive
           string that can be used for error handling. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
An error description string if {\tt e} is known, otherwise {\tt NULL}. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_err\_hook 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_exist  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_exist }
\addcontentsline{toc}{section}{bdd\_exist }
\index{bdd\_exist }
\--- existential quantification of variables  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_exist(BDD r, BDD var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Removes all occurences in {\tt r} of variables in the set
           {\tt var} by existential quantification. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The quantified BDD. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_forall, bdd\_unique, bdd\_makeset 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_extvarnum  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_extvarnum }
\addcontentsline{toc}{section}{bdd\_extvarnum }
\index{bdd\_extvarnum }
\--- add extra BDD variables  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_extvarnum(int num) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Extends the current number of allocated BDD variables with
           {\tt num} extra variables. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The old number of allocated variables or a negative error code. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_setvarnum, bdd\_ithvar, bdd\_nithvar 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_false  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_false }
\addcontentsline{toc}{section}{bdd\_false }
\index{bdd\_false }
\--- returns the constant false bdd  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_false(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function returns the constant false bdd and can freely be
           used together with the {\tt bddtrue} and {\tt bddfalse}
	   constants. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The constant false bdd 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_true, bddtrue, bddfalse 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_file\_hook  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_file\_hook }
\addcontentsline{toc}{section}{bdd\_file\_hook }
\index{bdd\_file\_hook }
\--- Specifies a printing callback handler  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bddfilehandler bdd_file_hook(bddfilehandler handler) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
A printing callback handler for use with BDDs is used to
           convert the BDD variable number into something readable by the
	   end user. Typically the handler will print a string name
	   instead of the number. A handler could look like this:
	   \begin{verbatim}
void printhandler(FILE *o, int var)
{
   extern char **names;
   fprintf(o, "%s", names[var]);
}
\end{verbatim}

           \noindent
           The handler can then be passed to BuDDy like this:
	   {\tt bdd\_file\_hook(printhandler)}.

	   No default handler is supplied. The argument {\tt handler} may be
	   NULL if no handler is needed. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The old handler 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_printset, bdd\_strm\_hook, fdd\_file\_hook 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_forall  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_forall }
\addcontentsline{toc}{section}{bdd\_forall }
\index{bdd\_forall }
\--- universal quantification of variables  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_forall(BDD r, BDD var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Removes all occurences in {\tt r} of variables in the set
           {\tt var} by universal quantification. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The quantified BDD. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_exist, bdd\_unique, bdd\_makeset 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_freepair  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_freepair }
\addcontentsline{toc}{section}{bdd\_freepair }
\index{bdd\_freepair }
\--- frees a table of pairs  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_freepair(bddPair *pair) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Frees the table of pairs {\tt pair} that has been allocated
           by a call to {\tt bdd\_newpair}. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_replace, bdd\_newpair, bdd\_setpair, bdd\_resetpair 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_fullsatone  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_fullsatone }
\addcontentsline{toc}{section}{bdd\_fullsatone }
\index{bdd\_fullsatone }
\--- finds one satisfying variable assignment  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_fullsatone(BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Finds a BDD with exactly one variable at all levels. This BDD
           implies {\tt r} and is not false unless {\tt r} is
	   false. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The result of the operation. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_allsat bdd\_satone, bdd\_satoneset, bdd\_satcount, bdd\_satcountln 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_gbc\_hook  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_gbc\_hook }
\addcontentsline{toc}{section}{bdd\_gbc\_hook }
\index{bdd\_gbc\_hook }
\--- set a handler for garbage collections  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bddgbchandler bdd_gbc_hook(bddgbchandler handler) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Whenever a garbage collection is required, a test is done to
         see if a handler for this event is supplied by the user and if such
	 exists then it is called, both before and after the garbage collection
	 takes places. This is indicated by an integer flag {\tt pre} passed to
	 the handler, which will be one before garbage collection and zero
	 after garbage collection.

	 This function sets the handler to be {\tt handler}. If a {\tt
	 NULL} argument is supplied then no calls are made when a
	 garbage collection takes place. The argument {\tt pre}
	 indicates pre vs. post garbage collection and the argument
	 {\tt stat} contains information about the garbage
	 collection. The default handler is {\tt bdd\_default\_gbchandler}.

	 Any handler should be defined like this:
	 \begin{verbatim}
void my_gbc_handler(int pre, bddGbcStat *stat)
{
   ...
}
\end{verbatim} 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The previous handler 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_resize\_hook, bdd\_reorder\_hook 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_getallocnum  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_getallocnum }
\addcontentsline{toc}{section}{bdd\_getallocnum }
\index{bdd\_getallocnum }
\--- get the number of allocated nodes  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_getallocnum(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the number of nodes currently allocated. This includes
           both dead and active nodes. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The number of nodes. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_getnodenum, bdd\_setmaxnodenum 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_getnodenum  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_getnodenum }
\addcontentsline{toc}{section}{bdd\_getnodenum }
\index{bdd\_getnodenum }
\--- get the number of active nodes in use  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_getnodenum(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the number of nodes in the nodetable that are
           currently in use. Note that dead nodes that have not been
	   reclaimed yet
	   by a garbage collection are counted as active. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The number of nodes. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_getallocnum, bdd\_setmaxnodenum 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_getreorder\_method  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_getreorder\_method }
\addcontentsline{toc}{section}{bdd\_getreorder\_method }
\index{bdd\_getreorder\_method }
\--- Fetch the current reorder method  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_getreorder_method(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the current reorder method as defined by
           {\tt bdd\_autoreorder}. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_reorder, bdd\_getreorder\_times 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_getreorder\_times  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_getreorder\_times }
\addcontentsline{toc}{section}{bdd\_getreorder\_times }
\index{bdd\_getreorder\_times }
\--- Fetch the current number of allowed reorderings  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_getreorder_times(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the current number of allowed reorderings left. This
           value can be defined by {\tt bdd\_autoreorder\_times}. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_reorder\_times, bdd\_getreorder\_method 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_high  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_high }
\addcontentsline{toc}{section}{bdd\_high }
\index{bdd\_high }
\--- gets the true branch of a bdd   \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_high(BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Gets the true branch of the bdd {\tt r}.  

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The bdd of the true branch 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_low 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_imp  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_imp }
\addcontentsline{toc}{section}{bdd\_imp }
\index{bdd\_imp }
\--- The logical 'implication' between two BDDs  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_imp(BDD l, BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This a wrapper that calls {\tt bdd\_apply(l,r,bddop\_imp)}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The logical 'implication' of {\tt l} and {\tt r} ($l \Rightarrow r$). 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_apply, bdd\_biimp 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_init  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_init }
\addcontentsline{toc}{section}{bdd\_init }
\index{bdd\_init }
\--- initializes the BDD package  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_init(int nodesize, int cachesize) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function initiates the bdd package and {\em must} be called
          before any bdd operations are done. The argument {\tt nodesize}
	  is the initial number of nodes in the nodetable and {\tt cachesize}
	  is the fixed size of the internal caches. Typical values for
	  {\tt nodesize} are 10000 nodes for small test examples and up to
	  1000000 nodes for large examples. A cache size of 10000 seems to
	  work good even for large examples, but lesser values should do it
	  for smaller examples.

	  The number of cache entries can also be set to depend on the size
	  of the nodetable using a call to {\tt bdd\_setcacheratio}.
	  
	  The initial number of nodes is not critical for any bdd operation
	  as the table will be resized whenever there are to few nodes left
	  after a garbage collection. But it does have some impact on the
	  efficency of the operations. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
If no errors occur then 0 is returned, otherwise
          a negative error code. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_done, bdd\_resize\_hook 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_isrunning  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_isrunning }
\addcontentsline{toc}{section}{bdd\_isrunning }
\index{bdd\_isrunning }
\--- test whether the package is started or not  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_isrunning(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function tests the internal state of the package and returns
          a status. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
1 (true) if the package has been started, otherwise 0. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_init, bdd\_done 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_ite  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_ite }
\addcontentsline{toc}{section}{bdd\_ite }
\index{bdd\_ite }
\--- if-then-else operator  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_ite(BDD f, BDD g, BDD h) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Calculates the BDD for the expression
           $(f \conj g) \disj (\neg f \conj h)$ more efficiently than doing
	   the three operations separately. {\tt bdd\_ite} can also be used
	   for conjunction, disjunction and any other boolean operator, but
	   is not as efficient for the binary and unary operations. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The BDD for $(f \conj g) \disj (\neg f \conj h)$ 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_apply 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_ithvar  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_ithvar }
\addcontentsline{toc}{section}{bdd\_ithvar }
\index{bdd\_ithvar }
\--- returns a bdd representing the I'th variable  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_ithvar(int var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function is used to get a bdd representing the I'th
           variable (one node with the childs true and false). The requested
	   variable must be in the range define by {\tt
	   bdd\_setvarnum} starting with 0 being the first. For ease
	   of use then the bdd returned from {\tt bdd\_ithvar} does
	   not have to be referenced counted with a call to {\tt
	   bdd\_addref}. The initial variable order is defined by the
	   the index {\tt var} that also defines the position in the
	   variable order -- variables with lower indecies are before
	   those with higher indecies. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The I'th variable on succes, otherwise the constant false bdd 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_setvarnum, bdd\_nithvar, bddtrue, bddfalse 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_level2var  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_level2var }
\addcontentsline{toc}{section}{bdd\_level2var }
\index{bdd\_level2var }
\--- Fetch the variable number of a specific level  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_level2var(int level) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the variable placed at position {\tt level} in the
           current variable order. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_reorder, bdd\_var2level 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_load  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_load }
\addcontentsline{toc}{section}{bdd\_load }
\index{bdd\_load }
\--- loads a BDD from a file  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_fnload(char *fname, BDD *r)
int bdd_load(FILE *ifile, BDD *r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Loads a BDD from a file into the BDD pointed to by {\tt r}.
           The file can either be the file {\tt ifile} which must be opened
	   for reading or the file named {\tt fname} which will be opened
	   automatically for reading.

	   The input file format consists of integers arranged in the following
	   manner. First the number of nodes $N$ used by the BDD and then the
	   number of variables $V$ allocated and the variable ordering
	   in use at the time the BDD was saved.
	   If $N$ and $V$ are both zero then the BDD is either the constant
	   true or false BDD, indicated by a $1$ or a $0$ as the next integer.

	   In any other case the next $N$ sets of $4$ integers will describe
	   the nodes used by the BDD. Each set consists of first the node
	   number, then the variable number and then the low and high nodes.

	   The nodes {\it must} be saved in a order such that any low or
	   high node must be defined before it is mentioned. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
Zero on succes, otherwise an error code from {\tt bdd.h}. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_save 
\addcontentsline{toc}{section}{bdd\_fnload }
\index{bdd\_fnload }
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_low  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_low }
\addcontentsline{toc}{section}{bdd\_low }
\index{bdd\_low }
\--- gets the false branch of a bdd   \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_low(BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Gets the false branch of the bdd {\tt r}.  

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The bdd of the false branch 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_high 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_makeset  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_makeset }
\addcontentsline{toc}{section}{bdd\_makeset }
\index{bdd\_makeset }
\--- builds a BDD variable set from an integer array  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_makeset(int *v, int n) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Reads a set of variable numbers from the integer array {\tt v}
           which must hold exactly {\tt n} integers and then builds a BDD
	   representing the variable set.

	   The BDD variable set is represented as the conjunction of
	   all the variables in their positive form and may just as
	   well be made that way by the user. The user should keep a
	   reference to the returned BDD instead of building it every
	   time the set is needed. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
A BDD variable set. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_scanset 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_newpair  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_newpair }
\addcontentsline{toc}{section}{bdd\_newpair }
\index{bdd\_newpair }
\--- creates an empty variable pair table  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bddPair *bdd_newpair(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Variable pairs of the type {\tt bddPair} are used in
           {\tt bdd\_replace} to define which variables to replace with
	   other variables. This function allocates such an empty table. The
	   table can be freed by a call to {\em bdd\_freepair}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
Returns a new table of pairs. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_freepair, bdd\_replace, bdd\_setpair, bdd\_setpairs 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_nithvar  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_nithvar }
\addcontentsline{toc}{section}{bdd\_nithvar }
\index{bdd\_nithvar }
\--- returns a bdd representing the negation of the I'th variable  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_nithvar(int var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function is used to get a bdd representing the negation of
           the I'th variable (one node with the childs false and true).
	   The requested variable must be in the range define by
	   {\tt bdd\_setvarnum} starting with 0 being the first. For ease of
	   use then the bdd returned from {\tt bdd\_nithvar} does not have
	   to be referenced counted with a call to {\tt bdd\_addref}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The negated I'th variable on succes, otherwise the constant false bdd 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_setvarnum, bdd\_ithvar, bddtrue, bddfalse 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_nodecount  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_nodecount }
\addcontentsline{toc}{section}{bdd\_nodecount }
\index{bdd\_nodecount }
\--- counts the number of nodes used for a BDD  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_nodecount(BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Traverses the BDD and counts all distinct nodes that are used
           for the BDD. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The number of nodes. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_pathcount, bdd\_satcount, bdd\_anodecount 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_not  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_not }
\addcontentsline{toc}{section}{bdd\_not }
\index{bdd\_not }
\--- negates a bdd  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_not(BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Negates the BDD {\tt r} by exchanging
           all references to the zero-terminal with references to the
	   one-terminal and vice versa. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The negated bdd. 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_or  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_or }
\addcontentsline{toc}{section}{bdd\_or }
\index{bdd\_or }
\--- The logical 'or' of two BDDs  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_or(BDD l, BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This a wrapper that calls {\tt bdd\_apply(l,r,bddop\_or)}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The logical 'or' of {\tt l} and {\tt r}. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_apply, bdd\_xor, bdd\_and 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_pathcount  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_pathcount }
\addcontentsline{toc}{section}{bdd\_pathcount }
\index{bdd\_pathcount }
\--- count the number of paths leading to the true terminal  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
double bdd_pathcount(BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Counts the number of paths from the root node {\tt r}
           leading to the terminal true node. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The number of paths 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_nodecount, bdd\_satcount 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_printall  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_printall }
\addcontentsline{toc}{section}{bdd\_printall }
\index{bdd\_printall }
\--- prints all used entries in the node table  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_printall(void)
void bdd_fprintall(FILE* ofile) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Prints to either stdout or the file {\tt ofile} all the used
           entries in the main node table. The format is:
	   \begin{Ill}
  	     {\tt [Nodenum] Var/level Low High}
	   \end{Ill}
	   Where {\tt Nodenum} is the position in the node table and level
	   is the position in the current variable order. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_printtable, bdd\_printset, bdd\_printdot 
\addcontentsline{toc}{section}{bdd\_fprintall }
\index{bdd\_fprintall }
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_printdot  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_printdot }
\addcontentsline{toc}{section}{bdd\_printdot }
\index{bdd\_printdot }
\--- prints a description of a BDD in DOT format  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_printdot(BDD r)
int bdd_fnprintdot(char* fname, BDD r)
void bdd_fprintdot(FILE* ofile, BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Prints a BDD in a format suitable for use with the graph
           drawing program DOT to either stdout, a designated file
	   {\tt ofile} or the file named by {\tt fname}. In the last case
	   the file will be opened for writing, any previous contents
	   destroyed and then closed again. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_printall, bdd\_printtable, bdd\_printset 
\addcontentsline{toc}{section}{bdd\_fprintdot }
\index{bdd\_fprintdot }
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_printorder  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_printorder }
\addcontentsline{toc}{section}{bdd\_printorder }
\index{bdd\_printorder }
\--- prints the current order  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_printorder(void)
bdd_fprint_order(FILE *f)
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Prints an indented list of the variable blocks, showing the top
           most blocks to the left and the lower blocks to the right.
	   Example:\\
	   \begin{verbatim}
  2{
     0
     1
  2}
  3
  4
\end{verbatim}
           This shows 5 variable blocks. The first one added is block zero,
	   which is on the same level as block one. These two blocks are then
	   sub-blocks of block two and block two is on the same level as
	   block three and four. The numbers are the identifiers returned
	   from {\tt bdd\_addvarblock}. The block levels depends on the
	   variables included in the blocks.
	   

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_reorder, bdd\_addvarblock 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_printset  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_printset }
\addcontentsline{toc}{section}{bdd\_printset }
\index{bdd\_printset }
\--- prints the set of truth assignments specified by a BDD  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bdd_printset(BDD r)
bdd_fprintset(FILE* ofile, BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Prints all the truth assignments for {\tt r} that would yield
           it true. The format is:
	   \begin{Ill}
	     {\tt < $x_{1,1}:c_{1,1},\ldots,x_{1,n_1}:c_{1,n_1}$ >\\
	          < $x_{2,1}:c_{2,1},\ldots,x_{2,n_2}:c_{2,n_2}$ >\\
		  $\ldots$ \\
	          < $x_{N,1}:c_{N,1},\ldots,x_{N,n_3}:c_{N,n_3}$ > }
	   \end{Ill} 
	   Where the $x$'s are variable numbers (and the position in the
	   current order) and the $c$'s are the
	   possible assignments to these. Each set of brackets designates
	   one possible assignment to the set of variables that make up the
	   BDD. All variables not shown are don't cares. It is possible to
	   specify a callback handler for printing of the variables using
	   {\tt bdd\_file\_hook} or {\tt bdd\_strm\_hook}. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_printall, bdd\_printtable, bdd\_printdot, bdd\_file\_hook, bdd\_strm\_hook 
\addcontentsline{toc}{section}{bdd\_fprintset }
\index{bdd\_fprintset }
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_printstat  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_printstat }
\addcontentsline{toc}{section}{bdd\_printstat }
\index{bdd\_printstat }
\--- print cache statistics  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_printstat(void)
void bdd_fprintstat(FILE *ofile) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Prints information about the cache performance on standard output
           (or the supplied file). The information contains the number of
	   accesses to the unique node table, the number of times a node
	   was (not) found there and how many times a hash chain had to
	   traversed. Hit and miss count is also given for the operator
	   caches. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bddCacheStat, bdd\_cachestats 
\addcontentsline{toc}{section}{bdd\_fprintstat }
\index{bdd\_fprintstat }
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_printtable  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_printtable }
\addcontentsline{toc}{section}{bdd\_printtable }
\index{bdd\_printtable }
\--- prints the node table entries used by a BDD  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_printtable(BDD r)
void bdd_fprinttable(FILE* ofile, BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Prints to either stdout or the file {\tt ofile} all the entries
           in the main node table used by {\tt r}. The format is:
	   \begin{Ill}
  	     {\tt [Nodenum] Var/level :  Low High}
	   \end{Ill}
	   Where {\tt Nodenum} is the position in the node table and level
	   is the position in the current variable order. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_printall, bdd\_printset, bdd\_printdot 
\addcontentsline{toc}{section}{bdd\_fprinttable }
\index{bdd\_fprinttable }
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_relprod  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_relprod }
\addcontentsline{toc}{section}{bdd\_relprod }
\index{bdd\_relprod }
\--- relational product  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
#define bdd_relprod(a,b,var) bdd_appex(a,b,bddop_and,var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Calculates the relational product of {\tt a} and {\tt b} as
           {\tt a AND b} with the variables in {\tt var} quantified out
	   afterwards. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The relational product or {\tt bddfalse} on errors. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_appex 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_reorder  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_reorder }
\addcontentsline{toc}{section}{bdd\_reorder }
\index{bdd\_reorder }
\--- start dynamic reordering  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_reorder(int method) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function initiates dynamic reordering using the heuristic
           defined by {\tt method}, which may be one of the following
	   \begin{description}
	     \item {\tt BDD\_REORDER\_WIN2}\\
	       Reordering using a sliding window of size 2. This algorithm
	       swaps two adjacent variable blocks and if this results in
	       more nodes then the two blocks are swapped back again.
	       Otherwise the result is kept in the variable order. This is
	       then repeated for all variable blocks.
	     \item {\tt BDD\_REORDER\_WIN2ITE}\\
	       The same as above but the process is repeated until no further
	       progress is done. Usually a fast and efficient method.
	     \item {\tt BDD\_REORDER\_WIN3}\\
	       The same as above but with a window size of 3.
	     \item {\tt BDD\_REORDER\_WIN2ITE}\\
	       The same as above but with a window size of 3.
	     \item {\tt BDD\_REORDER\_SIFT}\\
	       Reordering where each block is moved through all possible
	       positions. The best of these is then used as the new position.
	       Potentially a very slow but good method.
	     \item {\tt BDD\_REORDER\_SIFTITE}\\
	       The same as above but the process is repeated until no further
	       progress is done. Can be extremely slow.
	     \item {\tt BDD\_REORDER\_RANDOM}\\
	       Mostly used for debugging purpose, but may be usefull for
	       others. Selects a random position for each variable.
	   \end{description}
	   

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_autoreorder, bdd\_reorder\_verbose, bdd\_addvarblock, bdd\_clrvarblocks 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_reorder\_gain  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_reorder\_gain }
\addcontentsline{toc}{section}{bdd\_reorder\_gain }
\index{bdd\_reorder\_gain }
\--- Calculate the gain in size after a reordering  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_reorder_gain(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the gain in percent of the previous number of used
           nodes. The value returned is
	   \[ (100 * (A - B)) / A \]
	   Where $A$ is previous number of used nodes and $B$ is current
	   number of used nodes.
	
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_reorder\_hook  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_reorder\_hook }
\addcontentsline{toc}{section}{bdd\_reorder\_hook }
\index{bdd\_reorder\_hook }
\--- sets a handler for automatic reorderings  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bddinthandler bdd_reorder_hook(bddinthandler handler) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Whenever automatic reordering is done, a check is done to see
           if the user has supplied a handler for that event. If so then
	   it is called with the argument {\tt prestate} being 1 if the
	   handler is called immediately {\em before} reordering and
	   {\tt prestate} being 0 if it is called immediately after.
	   The default handler is
	   {\tt bdd\_default\_reohandler} which will print information
	   about the reordering.

	   A typical handler could look like this:
	   \begin{verbatim}
void reorderhandler(int prestate)
{
   if (prestate)
      printf("Start reordering");
   else
      printf("End reordering");
}
\end{verbatim} 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The previous handler 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_reorder, bdd\_autoreorder, bdd\_resize\_hook 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_reorder\_probe  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_reorder\_probe }
\addcontentsline{toc}{section}{bdd\_reorder\_probe }
\index{bdd\_reorder\_probe }
\--- Define a handler for minimization of BDDs  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bddsizehandler bdd_reorder_probe(bddsizehandler handler) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Reordering is typically done to minimize the global number of
           BDD nodes in use, but it may in some cases be usefull to minimize
	   with respect to a specific BDD. With {\tt bdd\_reorder\_probe} it
	   is possible to define a callback function that calculates the
	   size of a specific BDD (or anything else in fact). This handler
	   will then be called by the reordering functions to get the current
	   size information. A typical handle could look like this:
\begin{verbatim}
int sizehandler(void)
{
   extern BDD mybdd;
   return bdd_nodecount(mybdd);
}
\end{verbatim}
	   No default handler is supplied. The argument {\tt handler} may be
	   NULL if no handler is needed. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The old handler 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_reorder 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_reorder\_verbose  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_reorder\_verbose }
\addcontentsline{toc}{section}{bdd\_reorder\_verbose }
\index{bdd\_reorder\_verbose }
\--- enables verbose information about reorderings  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_reorder_verbose(int v) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
With {\tt bdd\_reorder\_verbose} it is possible to set the level
           of information which should be printed during reordering. A value
	   of zero means no information, a value of one means some information
	   and any greater value will result in a lot of reordering
	   information. The default value is zero. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The old verbose level 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_reorder 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_replace  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_replace }
\addcontentsline{toc}{section}{bdd\_replace }
\index{bdd\_replace }
\--- replaces variables with other variables  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_replace(BDD r, bddPair *pair) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Replaces all variables in the BDD {\tt r} with the variables
           defined by {\tt pair}. Each entry in {\tt pair} consists of a
	   old and a new variable. Whenever the old variable is found in
	   {\tt r} then a new node with the new variable is inserted instead.
	

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The result of the operation. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_newpair, bdd\_setpair, bdd\_setpairs 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_resetpair  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_resetpair }
\addcontentsline{toc}{section}{bdd\_resetpair }
\index{bdd\_resetpair }
\--- clear all variable pairs  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_resetpair(bddPair *pair) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Resets the table of pairs {\tt pair} by setting all substitutions
           to their default values (that is no change). 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_newpair, bdd\_setpair, bdd\_freepair 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_resize\_hook   ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_resize\_hook  }
\addcontentsline{toc}{section}{bdd\_resize\_hook  }
\index{bdd\_resize\_hook  }
\--- set a handler for nodetable resizes  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bdd2inthandler bdd_resize_hook(bdd2inthandler handler) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Whenever it is impossible to get enough free nodes by a garbage
         collection then the node table is resized and a test is done to see
	 if a handler is supllied by the user for this event. If so then
	 it is called with {\tt oldsize} being the old nodetable size and
	 {\tt newsize} being the new nodetable size.

	 This function sets the handler to be {\tt handler}. If a {\tt NULL}
	 argument is supplied then no calls are made when a table resize
	 is done. No default handler is supplied.

	 Any handler should be defined like this:
	 \begin{verbatim}
void my_resize_handler(int oldsize, int newsize)
{
   ...
}
\end{verbatim} 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The previous handler 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_gbc\_hook, bdd\_reorder\_hook, bdd\_setminfreenodes  
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_restrict  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_restrict }
\addcontentsline{toc}{section}{bdd\_restrict }
\index{bdd\_restrict }
\--- restric a set of variables to constant values  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_restrict(BDD r, BDD var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function restricts the variables in {\tt r} to constant
           true or false. How this is done
	   depends on how the variables are included in the variable set
	   {\tt var}. If they
	   are included in their positive form then they are restricted to
	   true and vice versa. Unfortunately it is not possible to
	   insert variables in their negated form using {\tt bdd\_makeset},
	   so the variable set has to be build manually as a
	   conjunction of the variables. Example: Assume variable 1 should be
	   restricted to true and variable 3 to false.
	   \begin{verbatim}
  bdd X = make_user_bdd();
  bdd R1 = bdd_ithvar(1);
  bdd R2 = bdd_nithvar(3);
  bdd R = bdd_addref( bdd_apply(R1,R2, bddop_and) );
  bdd RES = bdd_addref( bdd_restrict(X,R) );
\end{verbatim}
	   

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The restricted bdd. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_makeset, bdd\_exist, bdd\_forall 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_satcount  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_satcount }
\addcontentsline{toc}{section}{bdd\_satcount }
\index{bdd\_satcount }
\--- calculates the number of satisfying variable assignments  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
double bdd_satcount(BDD r)
double bdd_satcountset(BDD r, BDD varset) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Calculates how many possible variable assignments there exists
           such that {\tt r} is satisfied (true). All defined
	   variables are considered in the first version. In the
	   second version, only the variables in the variable
	   set {\tt varset} are considered. This makes the function a
	   {\em lot} slower. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The number of possible assignments. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_satone, bdd\_fullsatone, bdd\_satcountln 
\addcontentsline{toc}{section}{bdd\_setcountset }
\index{bdd\_setcountset }
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_satcountln  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_satcountln }
\addcontentsline{toc}{section}{bdd\_satcountln }
\index{bdd\_satcountln }
\--- calculates the log. number of satisfying variable assignments  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
double bdd_satcountln(BDD r)
double bdd_satcountlnset(BDD r, BDD varset)
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Calculates how many possible variable assignments there
	   exists such that {\tt r} is satisfied (true) and returns
	   the logarithm of this. The result is calculated in such a
	   manner that it is practically impossible to get an
	   overflow, which is very possible for {\tt bdd\_satcount} if
	   the number of defined variables is too large. All defined
	   variables are considered in the first version. In the
	   second version, only the variables in the variable
	   set {\tt varset} are considered. This makes the function
	   a {\em lot} slower! 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The logarithm of the number of possible assignments. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_satone, bdd\_fullsatone, bdd\_satcount 
\addcontentsline{toc}{section}{bdd\_setcountlnset }
\index{bdd\_setcountlnset }
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_satone  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_satone }
\addcontentsline{toc}{section}{bdd\_satone }
\index{bdd\_satone }
\--- finds one satisfying variable assignment  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_satone(BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Finds a BDD with at most one variable at each level. This BDD
           implies {\tt r} and is not false unless {\tt r} is
	   false. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The result of the operation. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_allsat bdd\_satoneset, bdd\_fullsatone, bdd\_satcount, bdd\_satcountln 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_satoneset  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_satoneset }
\addcontentsline{toc}{section}{bdd\_satoneset }
\index{bdd\_satoneset }
\--- finds one satisfying variable assignment  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_satoneset(BDD r, BDD var, BDD pol) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Finds a minterm in {\tt r}. The {\tt var} argument is a
           variable set that defines a set of variables that {\em must} be
	   mentioned in the result. The polarity of these variables in
	   result---in case they are undefined in {\tt r}---are defined
	   by the {\tt pol} parameter. If {\tt pol} is the false BDD then
	   the variables will be in negative form, and otherwise they will
	   be in positive form. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The result of the operation. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_allsat bdd\_satone, bdd\_fullsatone, bdd\_satcount, bdd\_satcountln 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_save  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_save }
\addcontentsline{toc}{section}{bdd\_save }
\index{bdd\_save }
\--- saves a BDD to a file  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_fnsave(char *fname, BDD r)
int bdd_save(FILE *ofile, BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Saves the nodes used by {\tt r} to either a file {\tt ofile}
           which must be opened for writing or to the file named {\tt fname}.
	   In the last case the file will be truncated and opened for
	   writing. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
Zero on succes, otherwise an error code from {\tt bdd.h}. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_load 
\addcontentsline{toc}{section}{bdd\_fnsave }
\index{bdd\_fnsave }
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_scanset  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_scanset }
\addcontentsline{toc}{section}{bdd\_scanset }
\index{bdd\_scanset }
\--- returns an integer representation of a variable set  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_scanset(BDD r, int **v, int *n) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Scans a variable set {\tt r} and copies the stored variables into
           an integer array of variable numbers. The argument {\tt v} is
	   the address of an integer pointer where the array is stored and
	   {\tt n} is a pointer to an integer where the number of elements
	   are stored. It is the users responsibility to make sure the
	   array is deallocated by a call to {\tt free(v)}. The numbers
	   returned are guaranteed to be in ascending order. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
Zero on success, otherwise a negative error code. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_makeset 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_setcacheratio  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_setcacheratio }
\addcontentsline{toc}{section}{bdd\_setcacheratio }
\index{bdd\_setcacheratio }
\--- Sets the cache ratio for the operator caches  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_setcacheratio(int r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
The ratio between the number of nodes in the nodetable
           and the number of entries in the operator cachetables is called
	   the cache ratio. So a cache ratio of say, four, allocates one cache
	   entry for each four unique node entries. This value can be set with
	   {\tt bdd\_setcacheratio} to any positive value. When this is done
	   the caches are resized instantly to fit the new ratio.
	   The default is a fixed cache size determined at
	   initialization time. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The previous cache ratio or a negative number on error. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_init 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_setmaxincrease  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_setmaxincrease }
\addcontentsline{toc}{section}{bdd\_setmaxincrease }
\index{bdd\_setmaxincrease }
\--- set max. number of nodes used to increase node table  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_setmaxincrease(int size) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
The node table is expanded by doubling the size of the table
           when no more free nodes can be found, but a maximum for the
	   number of new nodes added can be set with {\tt bdd\_maxincrease}
	   to {\tt size} nodes. The default is 50000 nodes (1 Mb). 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The old threshold on succes, otherwise a negative error code. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_setmaxnodenum, bdd\_setminfreenodes 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_setmaxnodenum  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_setmaxnodenum }
\addcontentsline{toc}{section}{bdd\_setmaxnodenum }
\index{bdd\_setmaxnodenum }
\--- set the maximum available number of bdd nodes  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_setmaxnodenum(int size) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function sets the maximal number of bdd nodes the package may
         allocate before it gives up a bdd operation. The
	 argument {\tt size} is the absolute maximal number of nodes there
	 may be allocated for the nodetable. Any attempt to allocate more
	 nodes results in the constant false being returned and the error
	 handler being called until some nodes are deallocated.
	 A value of 0 is interpreted as an unlimited amount.
	 It is {\em not} possible to specify
	 fewer nodes than there has already been allocated. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The old threshold on succes, otherwise a negative error code. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_setmaxincrease, bdd\_setminfreenodes 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_setminfreenodes  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_setminfreenodes }
\addcontentsline{toc}{section}{bdd\_setminfreenodes }
\index{bdd\_setminfreenodes }
\--- set min. no. of nodes to be reclaimed after GBC.  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_setminfreenodes(int n) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Whenever a garbage collection is executed the number of free
           nodes left are checked to see if a resize of the node table is
	   required. If $X = (\mathit{bddfreenum}*100)/\mathit{maxnum}$
	   is less than or
	   equal to {\tt n} then a resize is initiated. The range of
	   {\tt X} is of course $0\ldots 100$ and has some influence
	   on how fast the package is. A low number means harder attempts
	   to avoid resizing and saves space, and a high number reduces
	   the time used in garbage collections. The default value is
	   20. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The old threshold on succes, otherwise a negative error code. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_setmaxnodenum, bdd\_setmaxincrease 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_setpair  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_setpair }
\addcontentsline{toc}{section}{bdd\_setpair }
\index{bdd\_setpair }
\--- set one variable pair  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_setpair(bddPair *pair, int oldvar, int newvar)
int bdd_setbddpair(bddPair *pair, BDD oldvar, BDD newvar) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Adds the pair {\tt (oldvar,newvar)} to the table of pairs
           {\tt pair}. This results in {\tt oldvar} being substituted
	   with {\tt newvar} in a call to {\tt bdd\_replace}. In the first
	   version {\tt newvar} is an integer representing the variable
	   to be replaced with the old variable.
	   In the second version {\tt oldvar} is a BDD.
	   In this case the variable {\tt oldvar} is substituted with the
	   BDD {\tt newvar}.
	   The possibility to substitute with any BDD as {\tt newvar} is
	   utilized in bdd\_compose, whereas only the topmost variable
	   in the BDD is used in bdd\_replace. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
Zero on success, otherwise a negative error code. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_newpair, bdd\_setpairs, bdd\_resetpair, bdd\_replace, bdd\_compose 
\addcontentsline{toc}{section}{bdd\_setbddpair }
\index{bdd\_setbddpair }
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_setpairs  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_setpairs }
\addcontentsline{toc}{section}{bdd\_setpairs }
\index{bdd\_setpairs }
\--- defines a whole set of pairs  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_setpairs(bddPair *pair, int *oldvar, int *newvar, int size)
int bdd_setbddpairs(bddPair *pair, int *oldvar, BDD *newvar, int size) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
As for {\tt bdd\_setpair} but with {\tt oldvar} and {\tt newvar}
           being arrays of variables (BDDs) of size {\tt size}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
Zero on success, otherwise a negative error code. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_newpair, bdd\_setpair, bdd\_replace, bdd\_compose 
\addcontentsline{toc}{section}{bdd\_setbddpairs }
\index{bdd\_setbddpairs }
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_setvarnum  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_setvarnum }
\addcontentsline{toc}{section}{bdd\_setvarnum }
\index{bdd\_setvarnum }
\--- set the number of used bdd variables  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_setvarnum(int num) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function is used to define the number of variables used in
           the bdd package. It may be called more than one time, but only
	   to increase the number of variables. The argument
	   {\tt num} is the number of variables to use. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
Zero on succes, otherwise a negative error code. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_ithvar, bdd\_varnum, bdd\_extvarnum 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_setvarorder  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_setvarorder }
\addcontentsline{toc}{section}{bdd\_setvarorder }
\index{bdd\_setvarorder }
\--- set a specific variable order  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_setvarorder(int *neworder) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function sets the current variable order to be the one
           defined by {\tt neworder}. The parameter {\tt neworder} is
	   interpreted as a sequence of variable indecies and the new
	   variable order is exactly this sequence. The array {\em must}
	   contain all the variables defined so far. If for instance the
	   current number of variables is 3 and {\tt neworder} contains
	   $[1,0,2]$ then the new variable order is $v_1 < v_0 < v_2$. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_reorder, bdd\_printorder 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_simplify  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_simplify }
\addcontentsline{toc}{section}{bdd\_simplify }
\index{bdd\_simplify }
\--- coudert and Madre's restrict function  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_simplify(BDD f, BDD d) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Tries to simplify the BDD {\tt f} by restricting it to the
           domaine covered by {\tt d}. No checks are done to see if the
	   result is actually smaller than the input. This can be done
	   by the user with a call to {\tt bdd\_nodecount}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The simplified BDD 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_restrict 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_stats  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_stats }
\addcontentsline{toc}{section}{bdd\_stats }
\index{bdd\_stats }
\--- returns some status information about the bdd package  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_stats(bddStat* stat) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function acquires information about the internal state of
           the bdd package. The status information is written into the
	   {\tt stat} argument. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bddStat 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_strm\_hook  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_strm\_hook }
\addcontentsline{toc}{section}{bdd\_strm\_hook }
\index{bdd\_strm\_hook }
\--- Specifies a printing callback handler  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bddstrmhandler bdd_strm_hook(bddstrmhandler handler) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
A printing callback handler for use with BDDs is used to
           convert the BDD variable number into something readable by the
	   end user. Typically the handler will print a string name
	   instead of the number. A handler could look like this:
	   \begin{verbatim}
void printhandler(ostream &o, int var)
{
   extern char **names;
   o << names[var];
}
\end{verbatim}

           \noindent
           The handler can then be passed to BuDDy like this:
	   {\tt bdd\_strm\_hook(printhandler)}.

	   No default handler is supplied. The argument {\tt handler} may be
	   NULL if no handler is needed. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The old handler 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_printset, bdd\_file\_hook, fdd\_strm\_hook 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_support  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_support }
\addcontentsline{toc}{section}{bdd\_support }
\index{bdd\_support }
\--- returns the variable support of a BDD  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_support(BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Finds all the variables that {\tt r} depends on. That is
           the support of {\tt r}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
A BDD variable set. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_makeset 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_swapvar  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_swapvar }
\addcontentsline{toc}{section}{bdd\_swapvar }
\index{bdd\_swapvar }
\--- Swap two BDD variables  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_swapvar(int v1, int v2) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Use {\tt bdd\_swapvar} to swap the position (in the current
           variable order) of the two BDD
           variables {\tt v1} and {\tt v2}. There are no constraints on the
	   position of the two variables before the call. This function may
	   {\em not} be used together with user defined variable blocks.
	   The swap is done by a series of adjacent variable swaps and
	   requires the whole node table to be rehashed twice for each call
	   to {\tt bdd\_swapvar}. It should therefore not be used were
	   efficiency is a major concern. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
Zero on succes and a negative error code otherwise. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_reorder, bdd\_addvarblock 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_true  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_true }
\addcontentsline{toc}{section}{bdd\_true }
\index{bdd\_true }
\--- returns the constant true bdd  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_true(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function returns the constant true bdd and can freely be
           used together with the {\tt bddtrue} and {\tt bddfalse}
	   constants. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The constant true bdd 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_false, bddtrue, bddfalse 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_unique  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_unique }
\addcontentsline{toc}{section}{bdd\_unique }
\index{bdd\_unique }
\--- unique quantification of variables  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_unique(BDD r, BDD var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Removes all occurences in {\tt r} of variables in the set
           {\tt var} by unique quantification. This type of quantification
	   uses a XOR operator instead of an OR operator as in the
	   existential quantification, and an AND operator as in the
	   universal quantification. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The quantified BDD. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_exist, bdd\_forall, bdd\_makeset 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_var  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_var }
\addcontentsline{toc}{section}{bdd\_var }
\index{bdd\_var }
\--- gets the variable labeling the bdd  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_var(BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Gets the variable labeling the bdd {\tt r}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The variable number. 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_var2level  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_var2level }
\addcontentsline{toc}{section}{bdd\_var2level }
\index{bdd\_var2level }
\--- Fetch the level of a specific BDD variable  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_var2level(int var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the position of the variable {\tt var} in the current
           variable order. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_reorder, bdd\_level2var 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_varblockall  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_varblockall }
\addcontentsline{toc}{section}{bdd\_varblockall }
\index{bdd\_varblockall }
\--- add a variable block for all variables  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bdd_varblockall(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Adds a variable block for all BDD variables declared so far.
           Each block contains one variable only. More variable blocks
	   can be added later with the use of {\tt bdd\_addvarblock} --
	   in this case the tree of variable blocks will have the blocks
	   of single variables as the leafs. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_addvarblock, bdd\_intaddvarblock 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_varnum  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_varnum }
\addcontentsline{toc}{section}{bdd\_varnum }
\index{bdd\_varnum }
\--- returns the number of defined variables  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_varnum(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function returns the number of variables defined by
           a call to {\tt bdd\_setvarnum}.

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The number of defined variables 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_setvarnum, bdd\_ithvar 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_varprofile  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_varprofile }
\addcontentsline{toc}{section}{bdd\_varprofile }
\index{bdd\_varprofile }
\--- returns a variable profile  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int *bdd_varprofile(BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Counts the number of times each variable occurs in the
           bdd {\tt r}. The result is stored and returned in an integer array
	   where the i'th position stores the number of times the i'th
	   variable occured in the BDD. It is the users responsibility to
	   free the array again using a call to {\tt free}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
A pointer to an integer array with the profile or NULL if an
           error occured. 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_veccompose  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_veccompose }
\addcontentsline{toc}{section}{bdd\_veccompose }
\index{bdd\_veccompose }
\--- simultaneous functional composition  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_veccompose(BDD f, bddPair *pair) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Uses the pairs of variables and BDDs in {\tt pair} to make
           the simultaneous substitution: $f[g_1/V_1, \ldots, g_n/V_n]$.
	   In this way one or more BDDs
	   may be substituted in one step. The BDDs in
	   {\tt pair} may depend on the variables they are substituting.
           {\tt bdd\_compose} may be used instead of
	   {\tt bdd\_replace} but is not as efficient when $g_i$ is a
	   single variable, the same applies to {\tt bdd\_restrict}.
	   Note that simultaneous substitution is not necessarily the same
	   as repeated substitution. Example:
	   $(x_1 \disj x_2)[x_3/x_1,x_4/x_3] = (x_3 \disj x_2) \neq
	   ((x_1 \disj x_2)[x_3/x_1])[x_4/x_3] = (x_4 \disj x_2)$. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The composed BDD 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_compose, bdd\_replace, bdd\_restrict 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_versionnum  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_versionnum }
\addcontentsline{toc}{section}{bdd\_versionnum }
\index{bdd\_versionnum }
\--- returns the version number of the bdd package  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bdd_versionnum(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function returns the version number of the bdd package. The
           number is in the range 10-99 for version 1.0 to 9.9. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_versionstr 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_versionstr  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_versionstr }
\addcontentsline{toc}{section}{bdd\_versionstr }
\index{bdd\_versionstr }
\--- returns a text string with version information  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
char* bdd_versionstr(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function returns a text string with information about the
           version of the bdd package. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_versionnum 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bdd\_xor  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bdd\_xor }
\addcontentsline{toc}{section}{bdd\_xor }
\index{bdd\_xor }
\--- The logical 'xor' of two BDDs  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD bdd_xor(BDD l, BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This a wrapper that calls {\tt bdd\_apply(l,r,bddop\_xor)}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The logical 'xor' of {\tt l} and {\tt r}. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_apply, bdd\_or, bdd\_and 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bddfalse ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bddfalse}
\addcontentsline{toc}{section}{bddfalse}
\index{bddfalse}
\--- the constant false bdd  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
extern const BDD bddfalse; 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This bdd holds the constant false value 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bddtrue, bdd\_true, bdd\_false 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bddtrue  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bddtrue }
\addcontentsline{toc}{section}{bddtrue }
\index{bddtrue }
\--- the constant true bdd  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
extern const BDD bddtrue; 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This bdd holds the constant true value 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bddfalse, bdd\_true, bdd\_false 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec }
\addcontentsline{toc}{section}{bvec }
\index{bvec }
\--- A boolean vector  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
typedef struct s_bvec
{
   int bitnum;
   BDD *bitvec;
} BVEC;

typedef BVEC bvec; 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This data structure is used to store boolean vectors. The field
           {\tt bitnum} is the number of elements in the vector and the
	   field {\tt bitvec} contains the actual BDDs in the vector.
	   The C++ version of {\tt bvec} is documented at the beginning of
	   this document 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_add  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_add }
\addcontentsline{toc}{section}{bvec\_add }
\index{bvec\_add }
\--- builds a boolean vector for addition  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_add(bvec l, bvec r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a new boolean vector that represents the addition of two
           other vectors. Each element $x_i$ in the result will represent
	   the function
	   \[ x_i = l_i\ \mbox{xor}\ r_i\ \mbox{xor}\ c_{i-1} \]
	   where the carry in $c_i$ is
	   \[ c_i = (l_i\ \mbox{and}\ r_i)\ \mbox{or}\ (c_{i-1}\ \mbox{and}
	            \ (l_i\ \mbox{or}\ r_i)). \]
	   It is important for efficency that the BDD
	   variables used in {\tt l} and {\tt r} are interleaved. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The result of the addition (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_sub, bvec\_mul, bvec\_shl 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_addref  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_addref }
\addcontentsline{toc}{section}{bvec\_addref }
\index{bvec\_addref }
\--- increase reference count of a boolean vector  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_addref(bvec v) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Use this function to increase the reference count of all BDDs
           in a {\tt v}. Please note that all boolean vectors returned
	   from BuDDy are reference counted from the beginning. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The boolean vector {\tt v} 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_delref 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_coerce  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_coerce }
\addcontentsline{toc}{section}{bvec\_coerce }
\index{bvec\_coerce }
\--- adjust the size of a boolean vector  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_coerce(int bitnum, bvec v) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Build a boolean vector with {\tt bitnum} elements copied from
           {\tt v}. If the number of elements in {\tt v} is greater than
	   {\tt bitnum} then the most significant bits are removed, otherwise
	   if number is smaller then the vector is padded with constant
	   false BDDs (zeros). 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The new boolean vector (which is already reference counted) 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_con  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_con }
\addcontentsline{toc}{section}{bvec\_con }
\index{bvec\_con }
\--- Build a boolean vector representing an integer value  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_con(int bitnum, int val) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a boolean vector that represents the value {\tt val}
           using {\tt bitnum} bits. The value will be represented with the
	   LSB at the position 0 and the MSB at position {\tt bitnum}-1.

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The boolean vector (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_true, bvec\_false, bvec\_var 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_copy  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_copy }
\addcontentsline{toc}{section}{bvec\_copy }
\index{bvec\_copy }
\--- create a copy of a bvec  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_copy(bvec src) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns a copy of {\tt src}. The result is reference counted. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_con 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_delref  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_delref }
\addcontentsline{toc}{section}{bvec\_delref }
\index{bvec\_delref }
\--- decrease the reference count of a boolean vector  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_delref(bvec v) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Use this function to decrease the reference count of all the
           BDDs in {\tt v}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The boolean vector {\tt v} 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_addref 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_div  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_div }
\addcontentsline{toc}{section}{bvec\_div }
\index{bvec\_div }
\--- builds a boolean vector for division  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bvec_div(bvec l, bvec r, bvec *res, bvec *rem) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a new boolean vector representing the integer division
           of {\tt l} with {\tt r}. The result of the division will be stored
	   in {\tt res} and the remainder of the division will be stored in
	   {\tt rem}. Both vectors should be initialized as the function
	   will try to release the nodes used by them. If an error occurs then
	   the nodes will {\em not} be freed.

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
Zero on success or a negative error code on error. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_mul, bvec\_divfixed, bvec\_add, bvec\_shl 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_divfixed  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_divfixed }
\addcontentsline{toc}{section}{bvec\_divfixed }
\index{bvec\_divfixed }
\--- builds a boolean vector for division by a constant  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bvec_div(bvec e, int c, bvec *res, bvec *rem) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a new boolean vector representing the integer division
           of {\tt e} with {\tt c}. The result of the division will be stored
	   in {\tt res} and the remainder of the division will be stored in
	   {\tt rem}. Both vectors should be initialized as the function
	   will try to release the nodes used by them. If an error occurs then
	   the nodes will {\em not} be freed. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
Zero on success or a negative error code on error. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_div, bvec\_mul, bvec\_add, bvec\_shl 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_equ  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_equ }
\addcontentsline{toc}{section}{bvec\_equ }
\index{bvec\_equ }
\--- calculates the truth value of $x = y$  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bdd bvec_equ(bvec l, bvec r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the BDD representing {\tt l = r}
           ({\em not} reference counted). Both vectors must have the
	   same number of bits. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_lth, bvec\_lte, bvec\_gth, bvec\_gte, bvec\_neq 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_false  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_false }
\addcontentsline{toc}{section}{bvec\_false }
\index{bvec\_false }
\--- build a vector of constant false BDDs  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_false(int bitnum) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a boolean vector with {\tt bitnum} elements, each of which
           are the constant false BDD. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The boolean vector (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_true, bvec\_con, bvec\_var 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_free  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_free }
\addcontentsline{toc}{section}{bvec\_free }
\index{bvec\_free }
\--- frees all memory used by a boolean vector  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void bvec_free(bvec v) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Use this function to release any unused boolean vectors. The
           decrease of the reference counts on the BDDs in {\tt v} is done
	   by {\tt bvec\_free}. 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_gte  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_gte }
\addcontentsline{toc}{section}{bvec\_gte }
\index{bvec\_gte }
\--- calculates the truth value of $x \geq y$  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bdd bvec_gte(bvec l, bvec r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the BDD representing {\tt l}$\geq${\tt r}
           ({\em not} reference counted). Both vectors must have the
	   same number of bits. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_lth, bvec\_gth, bvec\_gth, bvec\_equ, bvec\_neq 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_gth  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_gth }
\addcontentsline{toc}{section}{bvec\_gth }
\index{bvec\_gth }
\--- calculates the truth value of $x > y$  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bdd bvec_gth(bvec l, bvec r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the BDD representing {\tt l > r}
           ({\em not} reference counted). Both vectors must have the
	   same number of bits. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_lth, bvec\_lte, bvec\_gte, bvec\_equ, bvec\_neq 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_isconst  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_isconst }
\addcontentsline{toc}{section}{bvec\_isconst }
\index{bvec\_isconst }
\--- test a vector for constant true/false BDDs  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bvec_isconst(bvec v) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns non-zero if the vector {\tt v} consists of only constant
           true or false BDDs. Otherwise zero is returned. This test should
	   prelude any call to {\tt bvec\_val}. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_val, bvec\_con 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_ite  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_ite }
\addcontentsline{toc}{section}{bvec\_ite }
\index{bvec\_ite }
\--- calculates the if-then-else operator for a boolean vector  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_ite(bdd a, bvec b, bvec c) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a vector where the bdd {\tt a} has been applied bitwise to
           {\tt b} and {\tt c} in an if-then-else operation, such that
	   the result $r$ is:
	   \[
	     r_i = ite(a,b_i,c_i);
	   \] 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The if-then-else result. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_ite 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_lte  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_lte }
\addcontentsline{toc}{section}{bvec\_lte }
\index{bvec\_lte }
\--- calculates the truth value of $x \leq y$  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bdd bvec_lte(bvec l, bvec r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the BDD representing {\tt l}$\leq${\tt r}
           ({\em not} reference counted). Both vectors must have the
	   same number of bits. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_lth, bvec\_gth, bvec\_gte, bvec\_equ, bvec\_neq 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_lth  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_lth }
\addcontentsline{toc}{section}{bvec\_lth }
\index{bvec\_lth }
\--- calculates the truth value of $x < y$  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bdd bvec_lth(bvec l, bvec r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the BDD representing {\tt l < r}
           ({\em not} reference counted). Both vectors must have the
	   same number of bits. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_lte, bvec\_gth, bvec\_gte, bvec\_equ, bvec\_neq 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_map1  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_map1 }
\addcontentsline{toc}{section}{bvec\_map1 }
\index{bvec\_map1 }
\--- map a function onto a boolean vector  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_map1(bvec a, bdd (*fun)(bdd)) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Maps the function {\tt fun} onto all the elements in {\tt a}. The
           value returned from {\tt fun} is stored in a new vector which
	   is then returned. An example of a mapping function is
	   {\tt bdd\_not} which can be used like this\\

	   \indent {\tt bvec res = bvec\_map1(a, bdd\_not)}\\

	   \noindent to negate all the BDDs in {\tt a}.

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The new vector (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_map2, bvec\_map3 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_map2  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_map2 }
\addcontentsline{toc}{section}{bvec\_map2 }
\index{bvec\_map2 }
\--- map a function onto a boolean vector  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_map2(bvec a, bvec b, bdd (*fun)(bdd,bdd)) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Maps the function {\tt fun} onto all the elements in {\tt a} and
           {\tt b}. The value returned from {\tt fun} is stored in a new
	   vector which is then returned. An example of a mapping function
	   is {\tt bdd\_and} which can be used like this\\

	   \indent {\tt bvec res = bvec\_map2(a, b, bdd\_and)}\\

	   \noindent to calculate the logical 'and' of all the BDDs in
	   {\tt a} and {\tt b}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The new vector (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_map1, bvec\_map3 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_map3  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_map3 }
\addcontentsline{toc}{section}{bvec\_map3 }
\index{bvec\_map3 }
\--- map a function onto a boolean vector  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_map3(bvec a, bvec b, bvec c, bdd (*fun)(bdd,bdd,bdd)) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Maps the function {\tt fun} onto all the elements in {\tt a},
           {\tt b} and {\tt c}. The value returned from {\tt fun} is stored
	   in a new vector which is then returned. An example of a mapping
	   function is {\tt bdd\_ite} which can be used like this\\

	   \indent {\tt bvec res = bvec\_map3(a, b, c, bdd\_ite) }\\

	   \noindent to calculate the if-then-else function for each element
	   in {\tt a}, {\tt b} and {\tt c}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The new vector (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_map1, bvec\_map2 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_mul  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_mul }
\addcontentsline{toc}{section}{bvec\_mul }
\index{bvec\_mul }
\--- builds a boolean vector for multiplication  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_mul(bvec l, bvec r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a boolean vector representing the multiplication
           of {\tt l} and {\tt r}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The result of the multiplication (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_mulfixed, bvec\_div, bvec\_add, bvec\_shl 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_mulfixed  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_mulfixed }
\addcontentsline{toc}{section}{bvec\_mulfixed }
\index{bvec\_mulfixed }
\--- builds a boolean vector for multiplication with a constant  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_mulfixed(bvec e, int c) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a boolean vector representing the multiplication
           of {\tt e} and {\tt c}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The result of the multiplication (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_mul, bvec\_div, bvec\_add, bvec\_shl 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_neq  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_neq }
\addcontentsline{toc}{section}{bvec\_neq }
\index{bvec\_neq }
\--- calculates the truth value of $x \neq y$  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bdd bvec_neq(bvec l, bvec r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the BDD representing {\tt l}$\neq${\tt r}
           ({\em not} reference counted). Both vectors must have the
	   same number of bits. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_lte, bvec\_lth, bvec\_gth, bvec\_gth, bvec\_equ 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_shl  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_shl }
\addcontentsline{toc}{section}{bvec\_shl }
\index{bvec\_shl }
\--- shift left operation (symbolic)  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_shl(bvec l, bvec r, BDD c) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a boolean vector that represents {\tt l} shifted {\tt r}
           times to the left. The new empty elements will be set to {\tt c}.
	   The shift operation is fully symbolic and the number of bits
	   shifted depends on the current value encoded by {\tt r}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The result of the operation (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_add, bvec\_mul, bvec\_shlfixed, bvec\_shr 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_shlfixed  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_shlfixed }
\addcontentsline{toc}{section}{bvec\_shlfixed }
\index{bvec\_shlfixed }
\--- shift left operation (fixed number of bits)  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_shlfixed(bvec v, int pos, BDD c) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a boolean vector that represents {\tt v} shifted {\tt pos}
           times to the left. The new empty elements will be set to {\tt c}.

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The result of the operation (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_add, bvec\_mul, bvec\_shl, bvec\_shr 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_shr  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_shr }
\addcontentsline{toc}{section}{bvec\_shr }
\index{bvec\_shr }
\--- shift right operation (symbolic)  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_shr(bvec l, bvec r, BDD c) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a boolean vector that represents {\tt l} shifted {\tt r}
           times to the right. The new empty elements will be set to {\tt c}.
	   The shift operation is fully symbolic and the number of bits
	   shifted depends on the current value encoded by {\tt r}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The result of the operation (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_add, bvec\_mul, bvec\_shl, bvec\_shrfixed 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_shrfixed  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_shrfixed }
\addcontentsline{toc}{section}{bvec\_shrfixed }
\index{bvec\_shrfixed }
\--- shift right operation  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_shrfixed(bvec v, int pos, BDD c) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a boolean vector that represents {\tt v} shifted {\tt pos}
           times to the right. The new empty elements will be set to {\tt c}.

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The result of the operation (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_add, bvec\_mul, bvec\_shr, bvec\_shl 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_sub  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_sub }
\addcontentsline{toc}{section}{bvec\_sub }
\index{bvec\_sub }
\--- builds a boolean vector for subtraction  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_sub(bvec l, bvec r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a new boolean vector that represents the subtraction of two
           other vectors. Each element $x_i$ in the result will represent
	   the function
	   \[ x_i = l_i\ \mbox{xor}\ r_i\ \mbox{xor}\ c_{i-1} \]
	   where the carry in $c_i$ is
	   \[ c_i = (l_i\ \mbox{and}\ r_i\ \mbox{and}\ c_{i-1})\
	            \mbox{or}\ (\mbox{not}\ l_i\ \mbox{and}
	            \ (r_i\ \mbox{or}\ c_{i-1})). \]
	   It is important for efficency that the BDD
	   variables used in {\tt l} and {\tt r} are interleaved. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The result of the subtraction (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_add, bvec\_mul, bvec\_shl 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_true  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_true }
\addcontentsline{toc}{section}{bvec\_true }
\index{bvec\_true }
\--- build a vector of constant true BDDs  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_true(int bitnum) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a boolean vector with {\tt bitnum} elements, each of which
           are the constant true BDD. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The boolean vector (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_false, bvec\_con, bvec\_var 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_val  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_val }
\addcontentsline{toc}{section}{bvec\_val }
\index{bvec\_val }
\--- calculate the integer value represented by a boolean vector  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int bvec_val(bvec v) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Calculates the value represented by the bits in {\tt v} assuming
           that the vector {\tt v} consists of only constant true
           or false BDDs. The LSB is assumed to be at position zero. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The integer value represented by {\tt v}. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_isconst, bvec\_con 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_var  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_var }
\addcontentsline{toc}{section}{bvec\_var }
\index{bvec\_var }
\--- build a boolean vector with BDD variables  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_var(int bitnum, int offset, int step) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a boolean vector with the BDD variables $v_1, \ldots,
           v_n$ as the elements. Each variable will be the the variabled
	   numbered {\tt offset + N*step} where {\tt N} ranges from 0 to
	   {\tt bitnum}-1.

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The boolean vector (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_true, bvec\_false, bvec\_con 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_varfdd  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_varfdd }
\addcontentsline{toc}{section}{bvec\_varfdd }
\index{bvec\_varfdd }
\--- build a boolean vector from a FDD variable block  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_varfdd(int var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a boolean vector which will include exactly the
           variables used to define the FDD variable block {\tt var}. The
	   vector will have the LSB at position zero. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The boolean vector (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_var 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === bvec\_varvec  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf bvec\_varvec }
\addcontentsline{toc}{section}{bvec\_varvec }
\index{bvec\_varvec }
\--- build a boolean vector with the variables passed in an array  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bvec bvec_varvec(int bitnum, int *var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a boolean vector with the BDD variables listed in
           the array {\tt var}. The array must be of size {\tt bitnum}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The boolean vector (which is already reference counted) 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bvec\_var 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_clearall  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_clearall }
\addcontentsline{toc}{section}{fdd\_clearall }
\index{fdd\_clearall }
\--- clear all allocated FDD blocks  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void fdd_clearall(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Removes all defined finite domain blocks defined by
           {\tt fdd\_extdomain()} and {\tt fdd\_overlapdomain()} 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_domain  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_domain }
\addcontentsline{toc}{section}{fdd\_domain }
\index{fdd\_domain }
\--- BDD encoding of the domain of a FDD variable  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD fdd_domain(int var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns what corresponds to a disjunction of all possible
           values of the variable  {\tt var}.
	   This is more efficient than doing
	   {\tt fdd\_ithvar(var,0) OR fdd\_ithvar(var,1) ...} explicitely
	   for all values in the domain of {\tt var}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The encoding of the domain
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_domainnum  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_domainnum }
\addcontentsline{toc}{section}{fdd\_domainnum }
\index{fdd\_domainnum }
\--- number of defined finite domain blocks  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int fdd_domainnum(void) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the number of finite domain blocks define by calls to
           {\tt bdd\_extdomain}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The number of defined finite domain blocks
           or a negative error code 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
fdd\_domainsize, fdd\_extdomain 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_domainsize  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_domainsize }
\addcontentsline{toc}{section}{fdd\_domainsize }
\index{fdd\_domainsize }
\--- real size of a finite domain block  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int fdd_domainsize(int var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the size of the domain for the finite domain
           block {\tt var}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The size or a negative error code 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
fdd\_domainnum 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_equals  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_equals }
\addcontentsline{toc}{section}{fdd\_equals }
\index{fdd\_equals }
\--- returns a BDD setting two FD. blocks equal  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD fdd_equals(int f, int g) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Builds a BDD which is true for all the possible assignments to
           the variable blocks {\tt f} and {\tt g} that makes the blocks
	   equal. This is more or less just a shorthand for calling
	   {\tt fdd\_equ()}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The correct BDD or the constant false on errors. 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_extdomain  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_extdomain }
\addcontentsline{toc}{section}{fdd\_extdomain }
\index{fdd\_extdomain }
\--- adds another set of finite domain blocks  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int fdd_extdomain(int *dom, int num) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Extends the set of finite domain blocks with the {\tt num}
           domains in
           {\tt dom}. Each entry in {\tt dom} defines the size of a new
	   finite domain which later on can be used for finite state machine
	   traversal and other operations on finte domains. Each domain
	   allocates $\log_2(|dom[i]|)$ BDD variables to be used later.
	   The ordering is interleaved for the domains defined in each
	   call to {\tt bdd\_extdomain}. This means that assuming domain
	   $D_0$ needs 2 BDD variables $x_1$ and $x_2$, and another domain
	   $D_1$ needs 4 BDD variables $y_1,y_2,y_3$ and $y_4$, then the
	   order will be $x_1,y_1,x_2,y_2,y_3,y_4$. The index of the first
	   domain in {\tt dom} is returned. The index of the other domains
	   are offset from this index with the same offset as in {\tt dom}.

	   The BDD variables needed to encode the domain are created for the
	   purpose and do not interfere with the BDD variables already in
	   use. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The index of the first domain or a negative error code. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
fdd\_ithvar, fdd\_equals, fdd\_overlapdomain 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_file\_hook  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_file\_hook }
\addcontentsline{toc}{section}{fdd\_file\_hook }
\index{fdd\_file\_hook }
\--- Specifies a printing callback handler  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bddfilehandler fdd_file_hook(bddfilehandler handler) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
A printing callback handler for use with FDDs is used to
           convert the FDD integer identifier into something readable by the
	   end user. Typically the handler will print a string name
	   instead of the identifier. A handler could look like this:
	   \begin{verbatim}
void printhandler(FILE *o, int var)
{
   extern char **names;
   fprintf(o, "%s", names[var]);
}
\end{verbatim}

           \noindent
           The handler can then be passed to BuDDy like this:
	   {\tt fdd\_file\_hook(printhandler)}.

	   No default handler is supplied. The argument {\tt handler} may be
	   NULL if no handler is needed. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The old handler 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
fdd\_printset, bdd\_file\_hook 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_intaddvarblock  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_intaddvarblock }
\addcontentsline{toc}{section}{fdd\_intaddvarblock }
\index{fdd\_intaddvarblock }
\--- adds a new variable block for reordering  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int fdd_intaddvarblock(int first, int last, int fixed) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Works exactly like {\tt bdd\_addvarblock} except that
           {\tt fdd\_intaddvarblock} takes a range of FDD variables
	   instead of BDD variables. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
Zero on success, otherwise a negative error code. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_addvarblock, bdd\_intaddvarblock, bdd\_reorder 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_ithset  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_ithset }
\addcontentsline{toc}{section}{fdd\_ithset }
\index{fdd\_ithset }
\--- the variable set for the i'th finite domain block  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD fdd_ithset(int var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the variable set that contains the variables used to
           define the finite domain block {\tt var}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The variable set or the constant false BDD on error. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
fdd\_ithvar 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_ithvar  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_ithvar }
\addcontentsline{toc}{section}{fdd\_ithvar }
\index{fdd\_ithvar }
\--- the BDD for the i'th FDD set to a specific value  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD fdd_ithvar(int var, int val) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the BDD that defines the value {\tt val} for the
           finite domain block {\tt var}. The encoding places the
	   Least Significant Bit at the top of the BDD tree
	   (which means they will have the lowest variable index).
	   The returned BDD will be $V_0 \conj V_1 \conj \ldots
	   \conj V_N$ where each $V_i$ will be in positive or negative form
	   depending on the value of {\tt val}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The correct BDD or the constant false BDD on error. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
fdd\_ithset 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_makeset  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_makeset }
\addcontentsline{toc}{section}{fdd\_makeset }
\index{fdd\_makeset }
\--- creates a variable set for N finite domain blocks  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
BDD fdd_makeset(int *varset, int varnum) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns a BDD defining all the variable sets used to define
           the variable blocks in the array {\tt varset}. The argument
	   {\tt varnum} defines the size of {\tt varset}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The correct BDD or the constant false on errors. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
fdd\_ithset, bdd\_makeset 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_overlapdomain  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_overlapdomain }
\addcontentsline{toc}{section}{fdd\_overlapdomain }
\index{fdd\_overlapdomain }
\--- combine two FDD blocks into one  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int fdd_overlapdomain(int v1, int v2) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
This function takes two FDD blocks and merges them into a new one,
           such that the new one is encoded using both sets of BDD variables.
	   If {\tt v1} is encoded using the BDD variables $a_1, \ldots,
	   a_n$ and has a domain of $[0,N_1]$, and {\tt v2} is encoded using
	   $b_1, \ldots, b_n$ and has a domain of $[0,N_2]$, then the result
	   will be encoded using the BDD variables $a_1, \ldots, a_n, b_1,
	   \ldots, b_n$ and have the domain $[0,N_1*N_2]$. The use of this
	   function may result in some strange output from
	   {\tt fdd\_printset}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The index of the finite domain block 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
fdd\_extdomain 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_printset  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_printset }
\addcontentsline{toc}{section}{fdd\_printset }
\index{fdd\_printset }
\--- prints a BDD for a finite domain block  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
void fdd_printset(BDD r)
void fdd_fprintset(FILE *ofile, BDD f) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Prints the BDD {\tt f} using a set notation as in
           {\tt bdd\_printset} but with the index of the finite domain blocks
	   included instead of the BDD variables. It is possible to specify
	   a printing callback function with {\tt fdd\_file\_hook} or
	   {\tt fdd\_strm\_hook} which can be used to print the FDD
	   identifier in a readable form. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_printset, fdd\_file\_hook, fdd\_strm\_hook 
\addcontentsline{toc}{section}{fdd\_fprintset }
\index{fdd\_fprintset }
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_scanallvar  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_scanallvar }
\addcontentsline{toc}{section}{fdd\_scanallvar }
\index{fdd\_scanallvar }
\--- Finds one satisfying value of all FDD variables  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int* fdd_scanallvar(BDD r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Finds one satisfying assignment in {\tt r} of all the defined
           FDD variables. Each value is stored in an array which is
	   returned. The size of this array is exactly the number of
	   FDD variables defined. It is the user's responsibility to
	   free this array using {\tt free()}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
An array with all satisfying values. If {\tt r} is the trivially
           false BDD, then NULL is returned. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
fdd\_scanvar 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_scanset  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_scanset }
\addcontentsline{toc}{section}{fdd\_scanset }
\index{fdd\_scanset }
\--- scans a variable set  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int fdd_scanset(BDD r, int **varset, int *varnum) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Scans the BDD {\tt r} to find all occurences of FDD variables
           and then stores these in {\tt varset}. {\tt varset} will be set
	   to point to an array of size {\tt varnum} which will contain
	   the indices of the found FDD variables. It is the users
	   responsibility to free {\tt varset} after use. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
Zero on success or a negative error code on error. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
fdd\_makeset 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_scanvar  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_scanvar }
\addcontentsline{toc}{section}{fdd\_scanvar }
\index{fdd\_scanvar }
\--- Finds one satisfying value of a FDD variable  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int fdd_scanvar(BDD r, int var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Finds one satisfying assignment of the FDD variable {\tt var} in the
           BDD {\tt r} and returns this value. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The value of a satisfying assignment of {\tt var}. If {\tt r} is
           the trivially false BDD, then a negative value is returned. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
fdd\_scanallvar 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_setpair  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_setpair }
\addcontentsline{toc}{section}{fdd\_setpair }
\index{fdd\_setpair }
\--- defines a pair for two finite domain blocks  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int fdd_setpair(bddPair *pair, int p1, int p2) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Defines each variable in the finite domain block {\tt p1} to
           be paired with the corresponding variable in {\tt p2}. The result
	   is stored in {\tt pair} which must be allocated using
	   {\tt bdd\_makepair}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
Zero on success or a negative error code on error. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
fdd\_setpairs 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_setpairs  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_setpairs }
\addcontentsline{toc}{section}{fdd\_setpairs }
\index{fdd\_setpairs }
\--- defines N pairs for finite domain blocks  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int fdd_setpairs(bddPair *pair, int *p1, int *p2, int size) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Defines each variable in all the finite domain blocks listed in
           the array {\tt p1} to be paired with the corresponding variable
	   in {\tt p2}. The result
	   is stored in {\tt pair} which must be allocated using
	   {\tt bdd\_makeset}.

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
Zero on success or a negative error code on error. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_setpair 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_strm\_hook  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_strm\_hook }
\addcontentsline{toc}{section}{fdd\_strm\_hook }
\index{fdd\_strm\_hook }
\--- Specifies a printing callback handler  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
bddstrmhandler fdd_strm_hook(bddstrmhandler handler) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
A printing callback handler for use with FDDs is used to
           convert the FDD integer identifier into something readable by the
	   end user. Typically the handler will print a string name
	   instead of the identifier. A handler could look like this:
	   \begin{verbatim}
void printhandler(ostream &o, int var)
{
   extern char **names;
   o << names[var];
}
\end{verbatim}

           \noindent
           The handler can then be passed to BuDDy like this:
	   {\tt fdd\_strm\_hook(printhandler)}.

	   No default handler is supplied. The argument {\tt handler} may be
	   NULL if no handler is needed. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The old handler 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
fdd\_printset, bdd\_file\_hook 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_varnum  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_varnum }
\addcontentsline{toc}{section}{fdd\_varnum }
\index{fdd\_varnum }
\--- binary size of a finite domain block  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int fdd_varnum(int var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns the number of BDD variables used for the finite domain
           block {\tt var}. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The number of variables or a negative error code 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
fdd\_vars 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === fdd\_vars  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf fdd\_vars }
\addcontentsline{toc}{section}{fdd\_vars }
\index{fdd\_vars }
\--- all BDD variables associated with a finite domain block  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
int *fdd_vars(int var) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
Returns an integer array containing the BDD variables used to
           define the finite domain block {\tt var}. The size of the array
	   is the number of variables used to define the finite domain block.
	   The array will have the Least Significant Bit at pos 0. The
	   array must {\em not} be deallocated. 

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
Integer array contaning the variable numbers or NULL if
           {\tt v} is an unknown block. 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
fdd\_varnum 
\end{minipage}
\vspace{8ex}
\begin{minipage}{\textwidth}

% === operator{\tt<<}  ===
\noindent\begin{minipage}{\textwidth}
\rule{\textwidth}{0.5mm}
{\tt\bf operator{\tt<<} }
\addcontentsline{toc}{section}{operator{\tt<<} }
\index{operator{\tt<<} }
\--- C++ output operator for BDDs  \hspace{\fill}
\\\rule[1.5ex]{\textwidth}{0.5mm}
\end{minipage}

\noindent\begin{verbatim}
ostream &operator<<(ostream &o, const bdd_ioformat &f)
ostream &operator<<(ostream &o, const bdd &r) 
\end{verbatim}

\vspace{\parsep}\noindent
{\bf Description}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}\setlength{\parindent}{1em}
BDDs can be printed in various formats using the C++ iostreams
           library. The formats are the those used in {\tt bdd\_printset},
	   {\tt bdd\_printtable}, {\tt fdd\_printset} and {\tt bdd\_printdot}.
	   The format can be specified with the following format objects:
	   \begin{tabular}{ll}\\
	     {\tt bddset } & BDD level set format \\
	     {\tt bddtable } & BDD level table format \\
	     {\tt bdddot }   & Output for use with Dot \\
	     {\tt bddall }   & The whole node table \\
	     {\tt fddset }   & FDD level set format \\
	   \end{tabular}\\

	   \noindent
	   So a BDD {\tt x} can for example be printed as a table with the
	   command\\

	   \indent {\tt cout << bddtable << x << endl}.
	   

\setlength{\parindent}{0em}\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf Return value}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
The specified output stream 

\vspace{\parsep}\vspace{\baselineskip}\noindent
{\bf See also}\\\rule[1.5ex]{\textwidth}{0.2mm}\vspace{-1.5ex}
bdd\_strm\_hook, fdd\_strm\_hook 
\end{minipage}
\vspace{8ex}
